<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>소리 성찰실 (MelodyMind)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- WordCloud2.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wordcloud2.js/1.2.2/wordcloud2.min.js"></script>
    
    <!-- Leaflet (지도) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .prose {
            max-width: 65ch;
            line-height: 1.75;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="app"></div>

    <script>
        // =========================
        // Global State Management
        // =========================
        const state = {
            page: 0,
            loading: false,
            userId: "Guest",
            studentId: '',
            studentName: '',
            db: null,
            appData: {
                url: '', title: '', composer: '', artist: '',
                ensembleType1: '', ensembleType2: '', musicGenre: '', lyrics: '', experienceLevel: '초심',
                senseKeywords: [], senseText: '', senseColors: [], senseImage: null,
                senseExpressionType: [], senseExpressionText: '',
                senseExpressionMovement: null, // 카메라로 캡처한 이미지 (base64)
                senseExpressionSpace: null, // 지도에서 선택한 위치 { lat, lng, address }
                senseExpressionPattern: null, // 도형 그리기 캔버스 데이터 (base64)
                senseExpressionNature: [], // 선택한 자연 현상 사진들
                // 표현 타입별 질문 답변
                senseExpressionPatternAnswers: {}, // 그림 질문 답변
                senseExpressionMovementAnswers: {}, // 움직임 질문 답변
                senseExpressionNatureAnswers: {}, // 자연 현상 질문 답변
                senseExpressionSpaceAnswers: {}, // 지도 질문 답변
                senseExpressionPoetryAnswers: {}, // 시 질문 답변
                techSound: '', techRhythm: '', analysisHarmony: '', analysisForm: '',
                interpIntent: '', interpScene: '', evalArt: '', evalApply: '',
                feedback: {
                    senseScore: 50, techScore: 50, analysisScore: 50, consistencyScore: 50, aestheticScore: 50,
                    goodPoints: '', badPoints: '', structuredQuestion: '',
                    draftAppreciation: '', modelAppreciation: ''
                },
                finalAppreciation: '',
                scores: [50, 50, 50, 50, 50],
                colors: ['#3B82F6', '#1E40AF', '#6366F1'],
                strategy: { performance: '', appreciation: '', composition: '' }
            },
            feedbackInput: '',
            showErrorModal: false,
            errorMessage: '',
            visualizationScene: null,
            comparisonPageInitialized: false // 비교 페이지 초기화 여부
        };

        // =========================
        // Color Palette
        // =========================
        const COLOR_PALETTE = [
            { value: '#3B82F6', name: '파랑', description: '평화, 고요' },
            { value: '#EF4444', name: '빨강', description: '긴장, 역동' },
            { value: '#10B981', name: '초록', description: '안정, 자연' },
            { value: '#F59E0B', name: '노랑', description: '기쁨, 밝음' },
            { value: '#8B5CF6', name: '보라', description: '신비, 몽환' },
            { value: '#EC4899', name: '핑크', description: '부드러움, 따뜻함' },
            { value: '#F97316', name: '주황', description: '열정, 활기' },
            { value: '#06B6D4', name: '청록', description: '시원함, 맑음' },
            { value: '#4B5563', name: '회색', description: '쓸쓸함, 어두움' },
            { value: '#7C3AED', name: '자주', description: '우아함, 고상함' },
            { value: '#0EA5E9', name: '하늘', description: '자유, 희망' },
            { value: '#F43F5E', name: '로즈', description: '따뜻함, 애정' }
        ];

        // =========================
        // Icon Component (SVG)
        // =========================
        const icons = {
            Music: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>`,
            Feather: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5.26 10.74 3 13V19l6 2 3-3"/><path d="M14.49 5.51 16.2 3.8a2 2 0 0 1 2.83 2.83l-1.71 1.71"/><path d="m9 11 8.5-8.5"/><path d="m11 9 8.5-8.5"/><path d="M12 18H7"/><path d="M15 21v-3"/></svg>`,
            Eye: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>`,
            Gauge: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 14 4-4"/><path d="M3.34 19A8 8 0 1 1 12 20"/><path d="M18.83 14.66L17.2 13"/><path d="M13 13h6"/></svg>`,
            Lightbulb: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 14c.2-1.1.7-2.2 1.4-3.1 2-2.5 2.5-4.7 1.5-6.7-1-2-2.8-3.2-5.4-3.2h-.6C9.6 1 8 2.2 7 4.2c-1 2-.5 4.2 1.5 6.7.7.9 1.2 2 1.4 3.1"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>`,
            BarChart: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></svg>`,
            MessageCircle: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 21 1.9-5.7a8.5 8.5 0 1 1 3.8 3.8z"/><circle cx="12" cy="12" r="4"/></svg>`,
            X: (size = 20) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`
        };

        // =========================
        // Backend API Functions (.env 사용)
        // =========================
        // 개발 환경: Express 서버 직접 연결, 프로덕션: 현재 도메인 사용 (Netlify Functions)
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:3000'
            : window.location.origin; // ✅ Netlify Functions 사용

        async function analyzeWithGPT(systemInstruction, userPrompt, jsonOutput = false) {
            try {
                // 유튜브 링크 추출
                const youtubeUrl = state.appData.url || null;
                
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        systemInstruction,
                        userPrompt,
                        jsonOutput,
                        youtubeUrl
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.details || errorData.error || `HTTP error! status: ${response.status}`;
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                return data.result || "AI 분석에 실패했습니다.";
            } catch (error) {
                console.error("API Error:", error);
                const errorMessage = error.message || '알 수 없는 오류';
                throw new Error(`AI 분석 중 오류가 발생했습니다: ${errorMessage}`);
            }
        }

        // Google Forms 데이터 전송 함수
        async function sendToGoogleForms(formData) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/google-forms`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                const result = await response.json();
                return result;
            } catch (error) {
                console.error("Google Forms Error:", error);
                return { success: false, error: error.message };
            }
        }

        // Page 5에서 완료 버튼 클릭 시 Google Forms로 데이터 전송
        async function submitToGoogleForms() {
            state.loading = true;
            render();

            try {
                const googleFormsData = {
                    userId: state.userId,
                    studentId: state.studentId,
                    studentName: state.studentName,
                    timestamp: new Date().toISOString(),
                    // 악곡 정보
                    title: state.appData.title,
                    url: state.appData.url,
                    artist: state.appData.artist,
                    composer: state.appData.composer,
                    musicGenre: state.appData.musicGenre,
                    ensembleType1: state.appData.ensembleType1,
                    // 감상 데이터
                    senseKeywords: state.appData.senseKeywords.join(', '),
                    senseText: state.appData.senseText,
                    senseColors: state.appData.senseColors.length > 0 
                        ? state.appData.senseColors.map(c => {
                            const color = COLOR_PALETTE.find(p => p.value === c);
                            return color ? `${color.name}(${color.description})` : c;
                        }).join(', ')
                        : '',
                    senseExpressionType: state.appData.senseExpressionType.join(', '),
                    senseExpressionText: state.appData.senseExpressionText,
                    senseExpressionMovement: state.appData.senseExpressionMovement ? '이미지 캡처됨' : '',
                    senseExpressionSpace: state.appData.senseExpressionSpace ? JSON.stringify(state.appData.senseExpressionSpace) : '',
                    senseExpressionPattern: state.appData.senseExpressionPattern ? '그림 생성됨' : '',
                    senseExpressionNature: state.appData.senseExpressionNature.join(', '),
                    senseExpressionPatternAnswers: JSON.stringify(state.appData.senseExpressionPatternAnswers || {}),
                    senseExpressionMovementAnswers: JSON.stringify(state.appData.senseExpressionMovementAnswers || {}),
                    senseExpressionNatureAnswers: JSON.stringify(state.appData.senseExpressionNatureAnswers || {}),
                    senseExpressionSpaceAnswers: JSON.stringify(state.appData.senseExpressionSpaceAnswers || {}),
                    senseExpressionPoetryAnswers: JSON.stringify(state.appData.senseExpressionPoetryAnswers || {}),
                    techSound: state.appData.techSound,
                    techRhythm: state.appData.techRhythm,
                    analysisHarmony: state.appData.analysisHarmony,
                    analysisForm: state.appData.analysisForm,
                    interpIntent: state.appData.interpIntent,
                    interpScene: state.appData.interpScene,
                    evalArt: state.appData.evalArt,
                    evalApply: state.appData.evalApply,
                    // AI 분석 결과
                    senseScore: state.appData.scores[0],
                    techScore: state.appData.scores[1],
                    analysisScore: state.appData.scores[2],
                    consistencyScore: state.appData.scores[3],
                    aestheticScore: state.appData.scores[4],
                    goodPoints: state.appData.feedback.goodPoints,
                    badPoints: state.appData.feedback.badPoints,
                    structuredQuestion: state.appData.feedback.structuredQuestion,
                    draftAppreciation: state.appData.feedback.draftAppreciation,
                    modelAppreciation: state.appData.feedback.modelAppreciation,
                    feedbackInput: state.feedbackInput,
                    // 최종 결과
                    finalAppreciation: state.appData.finalAppreciation,
                    performanceStrategy: state.appData.strategy.performance,
                    appreciationStrategy: state.appData.strategy.appreciation,
                    compositionStrategy: state.appData.strategy.composition
                };

                const result = await sendToGoogleForms(googleFormsData);
                
                if (result.success) {
                    showModal("감상문이 성공적으로 제출되었습니다! 🎉\n\nGoogle Forms에 응답이 저장되었습니다.");
                } else {
                    showModal(`Google Forms 전송 중 오류가 발생했습니다.\n\n${result.error || '알 수 없는 오류'}`);
                }
            } catch (error) {
                console.error("Google Forms 전송 오류:", error);
                showModal("Google Forms 전송 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
            } finally {
                state.loading = false;
                render();
            }
        }

        function getAppreciationDataForAI() {
            const d = state.appData;
            const natureImages = [
                { id: 'storm', name: '폭풍', emoji: '⛈️' },
                { id: 'lightning', name: '번개', emoji: '⚡' },
                { id: 'rain', name: '비', emoji: '🌧️' },
                { id: 'snow', name: '눈', emoji: '❄️' },
                { id: 'wind', name: '바람', emoji: '💨' },
                { id: 'wave', name: '파도', emoji: '🌊' },
                { id: 'fire', name: '불', emoji: '🔥' },
                { id: 'cloud', name: '구름', emoji: '☁️' },
                { id: 'sunset', name: '일몰', emoji: '🌅' },
                { id: 'moon', name: '달', emoji: '🌙' },
                { id: 'star', name: '별', emoji: '⭐' },
                { id: 'ocean', name: '바다', emoji: '🌊' }
            ];
            
            return `
--- 학생이 입력한 악곡 정보 ---
악곡 제목: ${d.title || '미입력'}
작곡가: ${d.composer || '미입력'}
연주자/가수: ${d.artist || '미입력'}
음악 장르: ${d.musicGenre || '미입력'}
유튜브 링크: ${d.url || '미입력'}
경험 수준: ${d.experienceLevel}, 연주 형태: ${d.ensembleType1} - ${d.ensembleType2}

--- 1단계: 반응 (감각적 감상) ---
핵심 키워드: ${d.senseKeywords.join(', ') || '없음'}
자유 서술: ${d.senseText || '없음'}
선택 색상: ${d.senseColors.length > 0 ? d.senseColors.map(c => {
    const color = COLOR_PALETTE.find(p => p.value === c);
    return color ? `${color.name}(${color.description})` : c;
}).join(', ') : '없음'}

--- 1단계: 다른 방식으로 표현하기 (다교과 융합 표현) ---
${d.senseExpressionType.length > 0 ? d.senseExpressionType.map(t => {
    const typeNames = {
        'poetry': '📝 시적 표현/문구 (국어)',
        'movement': '💃 움직임/동작 (체육/무용)',
        'nature': '⚡ 자연 현상 (과학)',
        'space': '🏞️ 공간/장소 (사회/지리)',
        'pattern': '🔷 도형/패턴 (수학)'
    };
    let result = typeNames[t] || t;
    
    if (t === 'poetry' && d.senseExpressionText) {
        result += `: "${d.senseExpressionText}"`;
    } else if (t === 'movement' && d.senseExpressionMovement) {
        result += `: 움직임/동작을 카메라로 캡처하여 표현함 (체육/무용)`;
    } else if (t === 'space' && d.senseExpressionSpace) {
        const space = d.senseExpressionSpace;
        result += `: ${space.address || `${space.lat.toFixed(4)}, ${space.lng.toFixed(4)}`} (사회/지리)`;
    } else if (t === 'pattern' && d.senseExpressionPattern) {
        result += `: 도형/패턴을 그림으로 그려서 표현함 (수학)`;
    } else if (t === 'nature' && d.senseExpressionNature && d.senseExpressionNature.length > 0) {
        const natureNames = d.senseExpressionNature.map(id => {
            const nature = natureImages.find(img => img.id === id);
            return nature ? `${nature.emoji} ${nature.name}` : id;
        }).join(', ');
        result += `: ${natureNames} (과학)`;
    }
    
    // 질문 답변 추가
    if (t === 'pattern' && d.senseExpressionPatternAnswers && Object.keys(d.senseExpressionPatternAnswers).length > 0) {
        result += '\n  그림 표현 질문 답변:';
        if (d.senseExpressionPatternAnswers.colorReason) result += `\n    - 색 선택 이유: ${d.senseExpressionPatternAnswers.colorReason}`;
        if (d.senseExpressionPatternAnswers.sound) result += `\n    - 음악 소리와 그림의 연결: ${d.senseExpressionPatternAnswers.sound}`;
        if (d.senseExpressionPatternAnswers.importantPart) result += `\n    - 가장 중요한 부분: ${d.senseExpressionPatternAnswers.importantPart}`;
        if (d.senseExpressionPatternAnswers.whyImportant) result += `\n    - 중요하다고 생각한 이유: ${d.senseExpressionPatternAnswers.whyImportant}`;
    }
    if (t === 'movement' && d.senseExpressionMovementAnswers && Object.keys(d.senseExpressionMovementAnswers).length > 0) {
        result += '\n  움직임 표현 질문 답변:';
        if (d.senseExpressionMovementAnswers.description) result += `\n    - 동작 설명: ${d.senseExpressionMovementAnswers.description}`;
        if (d.senseExpressionMovementAnswers.reason) result += `\n    - 동작 선택 이유: ${d.senseExpressionMovementAnswers.reason}`;
        if (d.senseExpressionMovementAnswers.how) result += `\n    - 몸 움직임 방법: ${d.senseExpressionMovementAnswers.how}`;
        if (d.senseExpressionMovementAnswers.connection) result += `\n    - 동작과 음악의 연결: ${d.senseExpressionMovementAnswers.connection}`;
    }
    if (t === 'nature' && d.senseExpressionNatureAnswers && Object.keys(d.senseExpressionNatureAnswers).length > 0) {
        result += '\n  자연 현상 표현 질문 답변:';
        if (d.senseExpressionNatureAnswers.reason) result += `\n    - 자연 현상 선택 이유: ${d.senseExpressionNatureAnswers.reason}`;
        if (d.senseExpressionNatureAnswers.musicPart) result += `\n    - 음악의 어떤 부분이 자연 현상을 떠올리게 했는지: ${d.senseExpressionNatureAnswers.musicPart}`;
        if (d.senseExpressionNatureAnswers.movement) result += `\n    - 자연 현상의 움직임과 음악의 연결: ${d.senseExpressionNatureAnswers.movement}`;
        if (d.senseExpressionNatureAnswers.alternative) result += `\n    - 다른 자연 현상 대안: ${d.senseExpressionNatureAnswers.alternative}`;
    }
    if (t === 'space' && d.senseExpressionSpaceAnswers && Object.keys(d.senseExpressionSpaceAnswers).length > 0) {
        result += '\n  지도 표현 질문 답변:';
        if (d.senseExpressionSpaceAnswers.reason) result += `\n    - 장소 선택 이유: ${d.senseExpressionSpaceAnswers.reason}`;
        if (d.senseExpressionSpaceAnswers.connection) result += `\n    - 장소와 음악의 연결: ${d.senseExpressionSpaceAnswers.connection}`;
        if (d.senseExpressionSpaceAnswers.scene) result += `\n    - 장소에서의 음악 장면/상황: ${d.senseExpressionSpaceAnswers.scene}`;
    }
    if (t === 'poetry' && d.senseExpressionPoetryAnswers && Object.keys(d.senseExpressionPoetryAnswers).length > 0) {
        result += '\n  시적 표현 질문 답변:';
        if (d.senseExpressionPoetryAnswers.firstFeeling) result += `\n    - 가장 먼저 떠오른 느낌: ${d.senseExpressionPoetryAnswers.firstFeeling}`;
        if (d.senseExpressionPoetryAnswers.image) result += `\n    - 상상한 장면/이미지: ${d.senseExpressionPoetryAnswers.image}`;
        if (d.senseExpressionPoetryAnswers.importantWord) result += `\n    - 가장 중요한 단어와 이유: ${d.senseExpressionPoetryAnswers.importantWord}`;
        if (d.senseExpressionPoetryAnswers.favoriteLine) result += `\n    - 마음에 드는 구절과 이유: ${d.senseExpressionPoetryAnswers.favoriteLine}`;
    }
    
    return result;
}).join('\n') : '없음'}

--- 2단계: 기술 및 분석 ---
2-1. 소리 및 음색 (Timbre/Dynamics): ${d.techSound || '미입력'}
2-2. 속도 및 리듬 (Tempo/Rhythm): ${d.techRhythm || '미입력'}
3-1. 화성 및 분위기 (Harmony/Tonality): ${d.analysisHarmony || '미입력'}
3-2. 형식 및 전개 (Form/Structure): ${d.analysisForm || '미입력'}

--- 3단계: 해석 및 평가 ---
4-1. 작곡 의도 및 메시지 (Intent/Message): ${d.interpIntent || '미입력'}
4-2. 음악의 사회적 의미 및 역할 (Social Meaning/Role): ${d.interpScene || '미입력'}
5-1. 예술적 가치 평가 (Aesthetic Value): ${d.evalArt || '미입력'}
5-2. 융합 및 확장 적용 (Application/Fusion): ${d.evalApply || '미입력'}
            `;
        }

        async function generateFeedback() {
            state.loading = true;
            render();

            const appreciationData = getAppreciationDataForAI();
            const systemInstruction = `
당신은 음악 교육 전문가이자 비평가입니다. 펠트만/앤더슨의 5단계 비평 구조(반응-기술-분석-해석-평가)에 따라 학생의 감상문 데이터를 분석하고, 논리적/음악적 근거 제시 여부를 진단합니다.

**중요: 반드시 유효한 JSON 형식으로만 응답해야 합니다. 다른 텍스트나 설명 없이 순수 JSON만 반환하세요.**

**핵심 임무: 학생의 통합 감상문 초안 생성**
학생이 1~3단계에서 입력한 모든 항목(반응, 기술, 분석, 해석, 평가)을 **'학생의 통합 감상문 초안'**이라는 이름으로 **5단계 비평 구조에 맞춰 자연스러운 글 형태**로 통합하여 생성해야 합니다. 이 초안은 Page 4에 제시되어 학생이 보완할 수 있도록 합니다.

필수 JSON 구조:
{
  "senseScore": 숫자(1-100),
  "techScore": 숫자(1-100),
  "analysisScore": 숫자(1-100),
  "consistencyScore": 숫자(1-100),
  "aestheticScore": 숫자(1-100),
  "goodPoints": "문자열 (2-3가지 칭찬)",
  "badPoints": "문자열 (2-3가지 보완점)",
  "structuredQuestion": "문자열 (구조화된 질문 1개)",
  "draftAppreciation": "문자열 (학생의 1~3단계 입력을 종합한 통합 감상문 초안 - 자연스러운 글 형태)",
  "modelAppreciation": "문자열 (이 악곡에 대한 모범 감상문 예시)"
}

--- [0단계: 악곡 정보 정확성 검증 및 확정 (최우선)] ---
**가장 먼저 수행해야 할 작업**: YouTube Data API로 가져온 동영상 정보를 **참고 자료**로만 사용하고, **반드시 자신의 학습된 지식과 검색 능력을 활용하여 정확한 악곡 정보를 확정**하세요.

**⚠️ 중요 원칙: YouTube 정보를 그대로 믿지 마세요**
- YouTube 동영상 제목, 설명, 태그는 **사용자가 임의로 작성한 정보**일 수 있습니다.
- YouTube 정보는 **참고 자료**일 뿐이며, **절대적인 기준이 아닙니다**.
- YouTube 정보와 학습된 지식이 충돌하는 경우, **학습된 지식과 검색 결과를 우선**하세요.

**1단계: YouTube 정보 분석 (참고용)**
- 시스템이 제공한 YouTube 동영상 정보를 참고 자료로 분석하세요:
  * 동영상 제목에서 작곡가, 악곡 제목, 연주자 정보를 추출하세요 (하지만 이것이 정확하다고 가정하지 마세요)
  * 동영상 설명에서 악곡의 배경, 형식, 특징 등을 확인하세요 (하지만 이것이 정확하다고 가정하지 마세요)
  * 태그에서 관련 키워드를 확인하세요
  * **중요**: YouTube의 "채널명(channelTitle)"은 보통 "연주자/가수" 정보입니다. 학생이 입력한 "작곡가"와 비교하지 말고, "연주자/가수"와 비교하세요.

**2단계: 정확한 악곡 정보 검색 및 확정 (필수)**
- YouTube 정보에서 추출한 작곡가와 악곡 제목을 **단서**로 사용하여, **자신의 학습된 지식과 검색 능력을 활용**하여 다음 정보를 **정확하게** 확정하세요:
  * **작곡가의 정확한 이름과 생몰년도**
  * **악곡의 정확한 제목 (원어 포함)**
  * **작곡 시기 및 시대적 배경**
  * **주요 형식(소나타, 론도, 변주곡 등)**
  * **조성(장조/단조, 조표)**
  * **템포 표시(Allegro, Adagio, Presto 등) 및 실제 빠르기**
  * **셈여림(dynamics: forte, piano, crescendo 등)의 특징**
  * **특징적인 악기 구성 및 편성**
  * **리듬 패턴 및 특징**
  * **화성 진행의 특징**
  * **작곡가의 스타일 및 시대적 특징**

**3단계: 정보 검증 및 불일치 처리**
- 확정한 정확한 악곡 정보와 YouTube 정보를 비교하세요.
- YouTube 정보가 잘못되었거나 불일치하는 경우, **확정한 정확한 정보를 기준**으로 사용하세요.
- 확정한 정확한 악곡 정보와 학생이 입력한 제목/작곡가/연주자를 비교하세요.

**3단계: 학생 입력과 비교**
- 위에서 확정한 정확한 악곡 정보와 학생이 입력한 정보를 비교하세요:
  * **악곡 제목**: 학생이 입력한 "제목"과 확정한 악곡 제목이 일치하는가?
  * **작곡가**: 학생이 입력한 "작곡가"와 확정한 작곡가가 일치하는가?
  * **연주자/가수**: 학생이 입력한 "연주자"와 확정한 연주자가 일치하는가?
  * **장르**: 학생이 입력한 "장르"와 확정한 장르가 일치하는가?
- **⚠️ 중요**: YouTube의 "채널명(channelTitle)"은 "연주자/가수" 정보이므로, 학생이 입력한 "작곡가"가 아닌 "연주자"와 비교해야 합니다.
- **불일치 판정 기준**:
  * 악곡 제목이 완전히 다른 경우 (예: "마왕" vs "Tears")
  * 작곡가가 완전히 다른 경우 (예: "슈베르트" vs "소찬휘")
  * 연주자가 다르더라도 악곡 제목과 작곡가가 일치하면 불일치로 판정하지 마세요 (다른 연주 버전일 수 있음)
- **불일치가 발견되면**:
  - 즉시 모든 점수(senseScore, techScore, analysisScore, consistencyScore, aestheticScore)를 20점 이하로 낮게 평가하세요.
  - badPoints에 "⚠️ 심각한 불일치: 유튜브 링크의 실제 악곡은 [악곡 제목] / [작곡가]인데, 입력하신 정보는 [학생 입력 제목] / [학생 입력 작곡가]입니다. 다른 곡에 대한 감상을 작성하신 것 같습니다." 형식으로 명확히 지적하세요.
  - structuredQuestion에 "유튜브 링크의 실제 악곡([실제 악곡 제목] / [실제 작곡가])과 입력하신 정보([학생 입력])가 다릅니다. 올바른 악곡 정보를 확인하고 다시 감상해보시겠어요?" 같은 질문을 포함하세요.

**예시**: 
- 불일치 사례: 유튜브 링크가 "슈베르트 - 마왕(Erlkönig)"인데, 학생이 "소찬휘 - Tears"를 입력 → 명백한 불일치 (악곡 제목과 작곡가가 완전히 다름)
- 일치 사례: 유튜브 링크가 "베토벤 - 월광 소나타 (연주: 랑랑)"인데, 학생이 "월광 소나타 / 베토벤 (연주: 다른 피아니스트)"를 입력 → 일치 (연주자는 다르지만 악곡 제목과 작곡가가 같음)

--- [1단계: 확정된 정보를 기준으로 평가] ---
위에서 확정한 **정확한 악곡 정보**를 기준으로 학생의 감상문을 평가하세요.

**확정해야 할 객관적 정보**:
- 시대적 배경 및 작곡 시기
- 주요 형식(소나타, 론도, 변주곡 등)
- 조성(장조/단조, 조표)
- 템포 표시(Allegro, Adagio, Presto 등) 및 실제 빠르기
- 셈여림(dynamics: forte, piano, crescendo 등)의 특징
- 특징적인 악기 구성 및 편성
- 리듬 패턴 및 특징
- 화성 진행의 특징
- 작곡가의 스타일 및 시대적 특징

이 확정된 객관적 정보를 '참고 기준(Reference Standard)'으로 설정하고, 학생의 감상문이 이 기준과 얼마나 일치하는지를 평가해야 합니다.

--- [2단계: 분석 기준 및 평가] ---
**악곡 정보 불일치가 없는 경우에만** 검색된 객관적 악곡 정보를 기준으로 다음 항목을 평가합니다:

**중요: 1단계 감각적 감상과 2단계 분석적 감상의 연결성 평가**
- 2단계 분석은 1단계에서 느낀 감각적 감상의 **근거**를 찾는 과정입니다.
- 학생이 1단계에서 "느리다"고 느꼈다면, 2단계에서는 "템포가 느리다"고 분석하여 그 느낌의 근거를 제시해야 합니다.
- 즉, 2단계 분석이 1단계 감각적 감상의 "왜 그렇게 느꼈을까?"에 대한 답이 되어야 합니다.

1. 감각적 민감도(senseScore): 
   - 학생의 감각적 서술(P1)이 검색된 악곡의 실제 셈여림/빠르기/조성과 얼마나 일치하는가?
   - 예: 학생이 "느리다"고 했으나 실제 곡이 Presto(매우 빠름)라면 점수를 낮게 평가
   - **악곡 정보 불일치 시: 10-20점**
   - (1-100점)

2. 기술적 정확도(techScore):
   - 학생의 기술(P2) 답변이 검색된 악곡의 객관적 음악 요소(악기 구성, 음색, 셈여림 등)를 얼마나 정확하게 기술했는가?
   - **중요**: 학생의 2단계 기술적 서술이 1단계 감각적 감상의 근거가 되는지 확인하세요.
   - 예: 1단계에서 "어둡고 무거운 느낌"을 느꼈다면, 2단계에서 "낮은 음역대의 악기" 또는 "forte의 셈여림" 등을 기술하여 그 느낌의 근거를 제시했는지 확인
   - 1단계 감각과 2단계 기술이 논리적으로 연결되면 높은 점수 부여
   - **악곡 정보 불일치 시: 10-20점**
   - (1-100점)

3. 분석적 이해도(analysisScore): 
   - 학생의 분석(P2) 답변이 검색된 악곡의 객관적 요소(형식, 조성, 리듬 패턴, 화성 진행 등)를 얼마나 정확하게 일치하는가?
   - **중요**: 학생의 2단계 분석적 서술이 1단계 감각적 감상의 근거가 되는지 확인하세요.
   - 예: 1단계에서 "느리다"고 느꼈다면, 2단계에서 "템포가 느리다" 또는 "Adagio로 시작한다"고 분석하여 그 느낌의 근거를 제시했는지 확인
   - 예: 1단계에서 "어두운 색상"을 선택했다면, 2단계에서 "단조로 되어있다" 또는 "불안정한 화음"이라고 분석하여 그 느낌의 근거를 제시했는지 확인
   - 1단계 감각과 2단계 분석이 논리적으로 연결되면 높은 점수 부여
   - 검색된 정보와 비교하여 정확도 평가
   - **악곡 정보 불일치 시: 10-20점** (다른 곡에 대한 분석이므로 정확도가 매우 낮음)
   - (1-100점)

4. 논리적 일관성(consistencyScore):
   - 학생의 감상문 전체가 논리적으로 일관성이 있는가? (P1→P2→P3의 연결성)
   - **핵심**: 1단계 감각적 감상(P1)과 2단계 분석적 감상(P2)의 연결성이 가장 중요합니다.
   - 1단계에서 느낀 것이 2단계에서 분석적 근거로 제시되었는지 확인
   - 예: 1단계 "느리다" → 2단계 "템포가 느리다" (연결됨) → 높은 점수
   - 예: 1단계 "느리다" → 2단계 "템포가 빠르다" (연결 안 됨) → 낮은 점수
   - 해석/평가(P3)가 기술/분석(P2)의 사실에 근거하는가?
   - **악곡 정보 불일치 시: 10-20점**
   - (1-100점)

5. 심미적 통찰력(aestheticScore): 
   - 학생의 해석/평가(P3) 내용이 검색된 시대적 배경, 작곡가 스타일과 얼마나 일치하는가?
   - 예술적 가치 판단의 깊이가 있는가?
   - **악곡 정보 불일치 시: 10-20점**
   - (1-100점)

4. goodPoints: 
   - **악곡 정보가 일치하는 경우에만** 검색된 객관적 정보와 일치하는 학생의 정확한 관찰이나 분석을 구체적으로 칭찬
   - **특히**: 1단계 감각적 감상과 2단계 분석적 감상이 잘 연결된 경우를 칭찬하세요.
   - 예: "1단계에서 느린 느낌을 느꼈고, 2단계에서 템포가 느리다는 분석적 근거를 제시하여 감각과 분석이 잘 연결되었습니다."
   - **악곡 정보 불일치 시**: "악곡 정보가 일치하지 않아 정확한 평가가 어렵습니다." 정도로 간단히 작성
   - 2~3가지

5. badPoints: 
   - **최우선**: 악곡 정보 불일치가 있으면 반드시 첫 번째 항목으로 지적하세요.
   - **중요**: YouTube 정보를 가져올 수 없었더라도, "실제 악곡: 확인 불가"라고 표시하지 마세요. 학생이 입력한 정보를 기반으로 학습된 지식을 활용하여 가능한 한 정확한 악곡 정보를 확정하고 평가하세요.
   - **불일치 표시 형식**: "⚠️ 심각한 불일치 감지: 유튜브 링크의 실제 악곡은 '[실제 악곡 제목] / 작곡: [실제 작곡가], 연주: [실제 연주자]'인데, 입력하신 정보는 '[학생 입력 제목] / 작곡: [학생 입력 작곡가], 연주: [학생 입력 연주자]'입니다. 다른 곡에 대한 감상을 작성하신 것 같습니다."
   - **YouTube 정보가 없는 경우**: "학생이 입력한 악곡 정보([학생 입력 정보])를 기반으로 학습된 지식을 활용하여 평가했습니다." 형식으로 작성하세요.
   - **중요**: 1단계 감각적 감상과 2단계 분석적 감상이 연결되지 않은 경우를 지적하세요.
   - 예: "1단계에서 '느리다'고 느꼈는데, 2단계에서는 '템포가 빠르다'고 분석하셨습니다. 1단계에서 느낀 감각의 근거를 찾는 것이 2단계의 목적입니다. 다시 들어보시고 1단계에서 느낀 감각의 근거가 되는 분석을 해보세요."
   - 그 다음 검색된 객관적 정보와 불일치하는 부분을 구체적으로 지적
   - 예: "당신은 곡의 템포가 느리다고 했으나, 실제 이 곡은 낭만주의 시대의 '매우 빠르다(Presto)'로 연주됩니다."
   - 논리적/음악적 근거 부족 등 보완할 점 2~3가지

6. structuredQuestion: 
   - **악곡 정보 불일치 시**: "유튜브 링크의 실제 악곡('[실제 악곡 제목] / 작곡: [실제 작곡가]')과 입력하신 정보('[학생 입력 제목] / 작곡: [학생 입력 작곡가]')가 다릅니다. 올바른 악곡 정보를 확인하고 해당 곡에 대해 다시 감상해보시겠어요?"
   - **YouTube 정보가 없는 경우**: "확인 불가"라고 표시하지 말고, 학생이 입력한 정보를 기반으로 학습된 지식을 활용하여 구체적인 질문을 제시하세요.
   - **1단계와 2단계 연결성 부족 시**: "1단계에서 [1단계 감각적 감상]을 느꼈는데, 2단계에서는 [2단계 분석]이라고 하셨습니다. 1단계에서 느낀 감각의 근거가 되는 분석을 찾아보시겠어요? 예를 들어, 1단계에서 느리다고 느꼈다면, 2단계에서는 템포가 어떻게 되어있는지 분석해보세요."
   - **일치하는 경우**: 학생이 틀리게 분석한 부분과 관련된 **검색된 객관적 정보의 일부**를 힌트로 활용하여 질문을 구체화
   - 예: "당신은 곡의 템포가 느리다고 했으나, 실제 이 곡은 낭만주의 시대의 '매우 빠르다(Presto)'로 연주됩니다. 리듬 패턴에 대한 기술을 보완할 수 있을까요? 특히 셋잇단음표의 반복 패턴이 어떻게 긴장감을 조성하는지 다시 들어보시겠어요?"
   - 보완할 점을 해결할 수 있도록 사고를 촉진하는 구조화된 질문 1개

7. draftAppreciation (학생의 통합 감상문 초안):
   - **핵심 임무**: 학생이 1~3단계에서 입력한 모든 항목을 **'학생의 통합 감상문 초안'**이라는 이름으로 **5단계 비평 구조에 맞춰 자연스러운 글 형태**로 통합하여 생성하세요.
   - **작성 방법**:
     * 학생이 입력한 내용(1단계: 반응, 2단계: 기술/분석, 3단계: 해석/평가)을 모두 포함하세요.
     * **중요**: 1단계의 "다른 방식으로 표현하기"에서 학생이 표현한 내용도 반드시 포함하세요.
       - 시적 표현/문구(국어): 학생이 입력한 시적 표현 텍스트를 감상문에 자연스럽게 포함
       - 움직임/동작(체육/무용): 학생이 카메라로 캡처한 움직임 표현이 있다는 것을 언급 (이미지는 별도로 표시되므로 텍스트에서는 언급만)
       - 자연 현상(과학): 학생이 선택한 자연 현상의 **구체적인 이름**(예: "폭풍", "번개", "비" 등)을 감상문에 반드시 포함하세요
       - 공간/장소(사회/지리): 학생이 선택한 위치의 **구체적인 주소나 위치 정보**를 감상문에 반드시 포함하세요 (예: "서울특별시 강남구..." 또는 "위도 37.5665, 경도 126.9780")
       - 도형/패턴(수학): 학생이 그린 도형/패턴 그림이 있다는 것을 언급 (이미지는 별도로 표시되므로 텍스트에서는 언급만)
     * 5단계 비평 구조(반응-기술-분석-해석-평가)에 맞춰 자연스럽게 연결하세요.
     * 각 단계의 내용을 문단으로 구성하여 읽기 좋은 감상문 형태로 작성하세요.
     * 문장을 다듬고 연결하여 완성도 높은 초안을 만들되, 학생의 원래 의도와 내용은 그대로 유지하세요.
   - **절대 금지**: 
     * 학생이 입력하지 않은 내용을 추가하지 마세요.
     * 학생이 입력한 내용만 사용하세요.
   - **최종 결과**: 이 초안은 Page 4에 제시되어 학생이 보완할 수 있도록 합니다.

8. modelAppreciation (모범 감상문 - 매우 중요):
   - **목표**: 음악 교사나 평론가 수준의 전문적이고 자세한 모범 감상문을 작성하세요.
   - **분량**: 학생 감상문보다 **최소 1.5배 이상 길고 구체적**으로 작성하세요. (최소 800-1200자 이상)
   - **YouTube 정보와 학습된 지식을 활용**하여 이 악곡에 대한 **모범 감상문 예시**를 작성하세요.
   - YouTube Data API로 가져온 동영상 정보와 자신의 학습된 지식을 종합하여 정확한 악곡 정보(제목, 작곡가, 시대, 형식, 조성, 템포 등)를 확정하세요.
   
   **작성 구조 (5단계 비평 구조를 완벽하게 반영)**:
   
   **1단계: 반응 (감각적 감상) - 200자 이상**
   - 첫 인상, 전체적인 분위기, 감정적 반응을 풍부하게 서술
   - 구체적인 감각적 표현 사용 (예: "첫 음부터 귓가를 사로잡는...", "마치 ~처럼 느껴지는...")
   - 색채적 표현, 촉각적 표현 등 다양한 감각을 활용
   - 예: "이 곡은 첫 음부터 강렬한 전자음이 귓가를 사로잡으며, 마치 밤의 도심 속 네온사인처럼 화려하고 역동적인 분위기를 자아낸다. 반복되는 베이스 라인은 심장 박동처럼 긴장감을 고조시키며..."
   
   **2단계: 기술 (음악적 요소 분석) - 300자 이상**
   - **소리 및 음색**: 사용된 악기, 전자음향, 음색의 특징을 구체적으로 분석
     * 예: "저음역의 신시사이저 베이스가 두껍고 무거운 질감을 만들며, 그 위로 날카로운 하이햇과 스네어 드럼이 명확한 리듬 구조를 형성한다"
   - **리듬 및 템포**: BPM, 리듬 패턴, 그루브감을 상세히 설명
     * 예: "중간 템포(약 120BPM)의 4/4박자로, 힙합 특유의 '붐뱁' 리듬에 트랩 비트의 하이햇 롤이 더해져 현대적인 사운드를 완성한다"
   - **화성 및 조성**: 조성, 화음 진행, 전조 등을 전문적으로 분석
     * 예: "단조 기반이지만 A 섹션에서 병행장조로 전환되며 밝고 희망적인 느낌을 더하고, 코러스에서는 4도 진행의 반복으로 긴장감을 유지한다"
   - **형식 및 구조**: 인트로-벌스-코러스-브릿지 등 구조를 명확히 분석
     * 예: "인트로(8마디) → 벌스1(16마디) → 프리코러스(8마디) → 코러스(16마디) → 벌스2(16마디) → 브릿지(8마디) → 코러스 반복(32마디) → 아웃트로(4마디)의 구조로, 전형적인 팝 송 형식을 따르지만 코러스의 반복 강조가 특징적이다"
   - **셈여림(Dynamics)**: 곡 전체의 다이나믹 변화를 섹션별로 상세히 분석
     * 예: "인트로는 mf(중간 셈여림)로 시작하여 벌스에서 mp(약간 여림)로 감소했다가, 프리코러스에서 점진적으로 크레센도하여 코러스에서 f(셈)로 폭발한다. 브릿지에서는 p(여림)로 대비를 주어 극적 효과를 극대화한다"
   
   **3단계: 해석 (의미와 맥락) - 200자 이상**
   - **작곡 의도**: 작곡가/아티스트의 의도, 곡의 메시지를 깊이 있게 해석
     * 예: "이 곡은 신인 그룹의 데뷔곡으로, '아직 유명하지 않지만(We ain't even famous)' 이미 충분한 실력과 자신감을 갖추었다는 역설적 메시지를 담고 있다. 젊은 세대의 당당함과 도전 정신을 표현한다"
   - **사회문화적 맥락**: 음악의 시대적, 사회적, 문화적 의미를 분석
     * 예: "2025년 K-POP의 글로벌화 트렌드를 반영하여 영어 가사 중심으로 구성되었으며, 힙합과 팝의 융합은 현대 대중음악의 장르 경계 해체를 보여준다. THE BLACK LABEL의 프로듀싱 스타일이 반영된 세련되고 공격적인 사운드가 특징이다"
   - **정서적 의미**: 곡이 불러일으키는 감정과 그 이유를 분석
     * 예: "반복되는 '유명하지 않다'는 가사와 대비되는 화려한 사운드는 청자에게 역설적인 긴장감을 주며, 이는 현대 젊은이들의 불안정한 정체성과 무한한 가능성을 동시에 표현한다"
   
   **4단계: 평가 (예술적 가치 판단) - 150자 이상**
   - **예술적 완성도**: 작곡, 편곡, 연주/퍼포먼스의 완성도를 평가
     * 예: "프로듀싱의 완성도가 매우 높으며, 각 멤버의 보컬과 랩이 조화롭게 배치되어 개성을 살리면서도 통일감을 유지한다. 특히 브릿지 부분의 음향 효과 처리는 공간감을 극대화하여 예술적 깊이를 더한다"
   - **독창성 및 혁신성**: 이 곡만의 독특한 특징이나 혁신적 요소
     * 예: "전통적인 K-POP 공식에 트랩과 하이퍼팝 요소를 가미한 사운드는 신선하며, 다국적 멤버 구성이 만들어내는 다층적 보컬 텍스처는 독창적이다"
   
   **5단계: 확장 (융합 및 활용) - 150자 이상**
   - **실용적 활용**: 이 곡의 실생활 활용 가능성을 구체적으로 제시
     * 예: "스포츠 경기 하이라이트 영상, 패션 브랜드 광고, 게임 OST, 운동 플레이리스트 등에 활용 가능하다. 특히 '유명하지 않다'는 메시지는 신생 브랜드나 스타트업의 광고 음악으로 적합하다"
   - **교육적 가치**: 음악 교육 관점에서의 활용
     * 예: "현대 대중음악의 프로듀싱 기법, 다국어 가사의 음운론적 처리, 글로벌 K-POP의 마케팅 전략 등을 학습하는 데 좋은 사례가 된다"
   - **다른 예술 장르와의 융합**: 무용, 미술, 영화 등과의 연계 가능성
     * 예: "강렬한 비트는 힙합 댄스나 현대무용의 안무 소재로 활용될 수 있으며, 네온 컬러의 시각적 이미지는 팝아트나 디지털 아트와 결합하여 멀티미디어 작품으로 발전 가능하다"
   
   **최종 요구사항**:
   - 확정된 악곡 정보를 바탕으로 5단계 비평 구조를 완벽하게 반영하세요.
   - 객관적 사실과 주관적 해석이 균형있게 조화된 감상문을 작성하세요.
   - 학생이 참고할 수 있는 **구체적이고 상세한** 모범 예시가 되도록 작성하세요.
   - **전문 용어를 적절히 사용**하되, 고등학생이 이해할 수 있는 수준으로 설명을 곁들이세요.
   - **구체적인 예시와 시간 표시**(예: "1분 23초 부분에서...")를 포함하여 설득력을 높이세요.
   - **중요**: YouTube 정보가 부족하거나 불확실한 경우에도, 학습된 지식을 활용하여 최선을 다해 모범 감상문을 작성하세요.
   - **절대 짧게 작성하지 마세요**: 학생 감상문보다 반드시 더 길고 자세해야 합니다.

--- [중요 지침] ---
- **최우선**: Google Search를 활용하여 유튜브 링크의 실제 악곡 정보를 검색하고, 학생 입력 정보와 비교하여 불일치를 반드시 감지하세요.
- **Google Search 필수 사용**: 모든 악곡 정보 검색은 Google Search를 통해 수행하세요. 학습된 지식만으로 판단하지 말고, 최신 정보를 검색하여 확인하세요.
- **Google Search 실행 방법**: 
  * 유튜브 링크 검색: "[유튜브 링크] 악곡 정보" 또는 "[유튜브 링크] 제목 작곡가"
  * 악곡 정보 검색: "[악곡 제목] [작곡가] 음악 정보" 또는 "[악곡 제목] [작곡가] 작곡 배경"
  * 검색 결과에서 위키피디아, 음악 전문 사이트, YouTube 메타데이터 등을 종합하여 정확한 정보를 추출하세요.
- 악곡 정보 불일치가 발견되면 즉시 낮은 점수(10-20점)를 부여하고 명확히 지적하세요.
- 악곡 정보가 일치하는 경우에만, Google Search를 통해 해당 악곡의 정확한 정보를 검색한 후 그 결과를 기준으로 학생의 답변을 평가하세요.
- 일반적인 지식에 의존하지 말고, Google Search를 통해 검색된 해당 악곡의 정확한 정보를 기반으로 분석해야 합니다.
- 피드백은 Google Search로 검색된 객관적 사실과 학생의 답변을 명확히 비교하여 제공해야 합니다.
            `;

            try {
                const gptResult = await analyzeWithGPT(systemInstruction, appreciationData, true);
                console.log("GPT Raw Result:", gptResult);
                
                // JSON 파싱 시도
                let parsedResult;
                try {
                    const cleanedResult = gptResult.replace(/```json|```/g, '').trim();
                    parsedResult = JSON.parse(cleanedResult);
                } catch (parseError) {
                    console.error("JSON Parse Error:", parseError);
                    console.error("Raw GPT Result:", gptResult);
                    throw new Error(`JSON 파싱 실패: ${parseError.message}\n\nGPT 응답: ${gptResult.substring(0, 200)}...`);
                }

                console.log("Parsed Result:", parsedResult);

                // 필수 필드 확인
                if (!parsedResult.senseScore || !parsedResult.techScore || !parsedResult.analysisScore || !parsedResult.consistencyScore || !parsedResult.aestheticScore) {
                    console.error("Missing required scores:", parsedResult);
                    throw new Error("AI 응답에 필수 점수 필드가 없습니다.");
                }

                state.appData.scores = [
                    parsedResult.senseScore || 50,
                    parsedResult.techScore || 50,
                    parsedResult.analysisScore || 50,
                    parsedResult.consistencyScore || 50,
                    parsedResult.aestheticScore || 50
                ];
                state.appData.feedback = {
                    senseScore: parsedResult.senseScore || 50,
                    techScore: parsedResult.techScore || 50,
                    analysisScore: parsedResult.analysisScore || 50,
                    consistencyScore: parsedResult.consistencyScore || 50,
                    aestheticScore: parsedResult.aestheticScore || 50,
                    goodPoints: parsedResult.goodPoints || 'AI가 칭찬 내용을 생성하지 못했습니다.',
                    badPoints: parsedResult.badPoints || 'AI가 보완점을 생성하지 못했습니다.',
                    structuredQuestion: parsedResult.structuredQuestion || 'AI가 질문을 생성하지 못했습니다.',
                    draftAppreciation: parsedResult.draftAppreciation || 'AI가 통합 감상문 초안을 생성하지 못했습니다.',
                    modelAppreciation: parsedResult.modelAppreciation || 'AI가 모범 감상문을 생성하지 못했습니다.'
                };
                state.page = 4;
            } catch (error) {
                console.error("Feedback generation error:", error);
                const errorMsg = error.message || "AI 분석 중 심각한 오류가 발생했습니다.";
                showModal(`AI 분석 오류\n\n${errorMsg}\n\n브라우저 콘솔(F12)에서 자세한 오류를 확인할 수 있습니다.`);
            } finally {
                state.loading = false;
                render();
            }
        }

        async function generateFinalOutput(finalInput) {
            state.loading = true;
            render();

            const appreciationData = getAppreciationDataForAI();
            const systemInstruction = `
당신은 음악 교육 전문가입니다. 학생의 감상문 초안과 보완 내용을 종합하여 아래 항목을 JSON 형식으로 생성해주세요.

--- [절대 지침: 학생 입력 내용만 사용] ---
**중요**: finalAppreciation은 반드시 학생이 입력한 내용만으로 구성되어야 합니다.

1. **학생이 입력한 내용만 사용**: 
   - "1~3단계 통합 감상 데이터"에 있는 학생의 모든 입력 내용
   - "보완된 감상 내용"에 학생이 직접 입력한 내용
   - 이 두 가지를 자연스럽게 연결하고 문장을 다듬어서 하나의 감상문으로 통합하세요.

2. **절대 금지 사항**:
   - 학생이 입력하지 않은 내용을 추가하지 마세요
   - 학생이 언급하지 않은 악곡 정보를 임의로 추가하지 마세요
   - 학생의 입력 내용을 바탕으로 문장을 다듬고 연결만 하세요

3. **작성 방법**:
   - 학생의 1단계(반응), 2단계(기술/분석), 3단계(해석/평가) 입력을 5단계 비평 구조에 맞게 재구성
   - **중요**: 1단계의 "다른 방식으로 표현하기"에서 학생이 표현한 내용도 반드시 포함하세요.
     - 시적 표현/문구(국어): 학생이 입력한 시적 표현 텍스트를 감상문에 자연스럽게 포함. **질문 답변 내용**(가장 먼저 떠오른 느낌, 상상한 장면/이미지, 중요한 단어, 마음에 드는 구절)도 반드시 포함하세요.
     - 움직임/동작(체육/무용): 학생이 카메라로 캡처한 움직임 표현이 있다는 것을 언급 (이미지는 별도로 표시되므로 텍스트에서는 언급만). **질문 답변 내용**(동작 설명, 선택 이유, 몸 움직임 방법, 음악과의 연결)도 반드시 포함하세요.
     - 자연 현상(과학): 학생이 선택한 자연 현상의 **구체적인 이름**(예: "폭풍", "번개", "비" 등)을 감상문에 반드시 포함하세요. **질문 답변 내용**(선택 이유, 음악의 어떤 부분이 자연 현상을 떠올리게 했는지, 움직임의 연결, 다른 자연 현상 대안)도 반드시 포함하세요.
     - 공간/장소(사회/지리): 학생이 선택한 위치의 **구체적인 주소나 위치 정보**를 감상문에 반드시 포함하세요 (예: "서울특별시 강남구..." 또는 "위도 37.5665, 경도 126.9780"). **질문 답변 내용**(장소 선택 이유, 장소와 음악의 연결, 장소에서의 음악 장면/상황)도 반드시 포함하세요.
     - 도형/패턴(수학): 학생이 그린 도형/패턴 그림이 있다는 것을 언급 (이미지는 별도로 표시되므로 텍스트에서는 언급만). **질문 답변 내용**(색 선택 이유, 음악 소리와 그림의 연결, 가장 중요한 부분, 중요하다고 생각한 이유)도 반드시 포함하세요.
   - 학생의 보완 내용을 적절한 위치에 통합
   - 문장을 자연스럽게 다듬되, 학생의 원래 의도와 내용은 그대로 유지

--- 생성 항목 ---
1. finalAppreciation: **학생이 입력한 내용만**을 사용하여 작성한 최종 감상문 텍스트
   - 학생의 모든 입력(1~3단계 + 보완 내용)을 자연스럽게 연결하여 하나의 완성된 감상문으로 작성
   - 1단계의 "다른 방식으로 표현하기" 내용도 반드시 포함하세요
   - 학생이 입력하지 않은 내용은 절대 추가하지 마세요

2. performanceStrategy: 연주 영역 활용 전략
   - **중요**: 학생이 입력한 악곡 정보가 아닌, **AI가 분석하여 확정한 정확한 악곡 정보**를 기반으로 작성하세요.
   - 해당 악곡의 정확한 작곡가, 시대, 형식, 조성, 템포, 특징 등을 고려한 구체적 연주 전략
   - 예: "이 곡은 [확정된 작곡가]의 [확정된 형식]로, [확정된 시대]의 특징인 [특징]을 연주할 때 주의해야 합니다..."

3. appreciationStrategy: 감상 영역 활용 전략
   - **중요**: 학생이 입력한 악곡 정보가 아닌, **AI가 분석하여 확정한 정확한 악곡 정보**를 기반으로 작성하세요.
   - 해당 악곡의 정확한 형식, 시대적 배경, 작곡가의 스타일 등을 활용한 감상 전략
   - 예: "이 곡은 [확정된 형식]로, [확정된 시대]의 [특징]을 이해하면 더 깊이 감상할 수 있습니다..."

4. compositionStrategy: 창작 영역 활용 전략
   - **중요**: 학생이 입력한 악곡 정보가 아닌, **AI가 분석하여 확정한 정확한 악곡 정보**를 기반으로 작성하세요.
   - 해당 악곡의 정확한 작곡 기법, 화성 진행, 리듬 패턴 등을 참고한 창작 전략
   - 예: "이 곡의 [확정된 작곡 기법]을 참고하여, [특징]을 활용한 창작 활동을 시도해볼 수 있습니다..."

**참고**: 
- 모범 감상문(modelAppreciation)은 이미 generateFeedback 단계에서 생성되었으므로, 여기서는 학생의 최종 감상문만 생성하면 됩니다.
- **전략 생성 시**: 반드시 자신이 generateFeedback 단계에서 확정한 정확한 악곡 정보(작곡가, 시대, 형식, 조성, 템포 등)를 활용하세요. 학생이 입력한 정보가 잘못되었을 수 있으므로, AI가 분석하여 확정한 정보를 사용해야 합니다.
            `;

            const userPrompt = `
--- 학생이 입력한 1~3단계 통합 감상 데이터 (finalAppreciation 작성 시에만 사용) ---
${appreciationData}

--- AI 피드백 (참고용) ---
칭찬: ${state.appData.feedback.goodPoints}
보완점: ${state.appData.feedback.badPoints}
질문: ${state.appData.feedback.structuredQuestion}

--- AI가 생성한 모범 감상문 (악곡 정보 참고용) ---
${state.appData.feedback.modelAppreciation || '모범 감상문이 없습니다.'}

**중요**: 위 모범 감상문은 AI가 정확한 악곡 정보를 기반으로 작성한 것입니다. 이 모범 감상문에서 사용된 정확한 악곡 정보(작곡가, 시대, 형식, 조성, 템포 등)를 참고하여 전략을 생성하세요.

--- 학생이 직접 입력한 보완된 감상 내용 (finalAppreciation에 반드시 포함) ---
${finalInput || '학생이 보완 내용을 입력하지 않았습니다.'}

**중요 지시사항**:
1. **finalAppreciation**: 위의 "1~3단계 통합 감상 데이터"와 "보완된 감상 내용"에 있는 학생의 입력 내용만을 사용하여 작성하세요. 학생이 입력하지 않은 내용은 절대 추가하지 마세요.

2. **전략 생성 (performanceStrategy, appreciationStrategy, compositionStrategy)**:
   - 학생이 입력한 악곡 정보는 참고만 하고, **반드시 AI가 모범 감상문에서 사용한 정확한 악곡 정보**를 기반으로 작성하세요.
   - 모범 감상문에서 언급된 작곡가, 시대, 형식, 조성, 템포, 작곡 기법 등을 활용하여 구체적이고 실용적인 전략을 제시하세요.
   - 학생이 입력한 정보가 잘못되었을 수 있으므로, AI가 확정한 정확한 정보를 사용해야 합니다.

3. 학생의 입력 내용을 자연스럽게 연결하고 문장을 다듬되, 학생의 원래 의도와 내용은 그대로 유지하세요.

4. 학생이 "미입력"이라고 표시된 항목은 해당 부분을 간략하게 처리하거나 생략하세요.

위 지시사항에 따라 최종 감상문과 미래 활용 전략을 생성해주세요.
            `;

            try {
                const gptResult = await analyzeWithGPT(systemInstruction, userPrompt, true);
                const parsedResult = JSON.parse(gptResult.replace(/```json|```/g, '').trim());

                state.appData.finalAppreciation = parsedResult.finalAppreciation;
                state.appData.strategy = {
                    performance: parsedResult.performanceStrategy,
                    appreciation: parsedResult.appreciationStrategy,
                    composition: parsedResult.compositionStrategy
                };

                // Google Forms로 데이터 전송
                const googleFormsData = {
                    userId: state.userId,
                    studentId: state.studentId,
                    studentName: state.studentName,
                    timestamp: new Date().toISOString(),
                    // 악곡 정보
                    title: state.appData.title,
                    url: state.appData.url,
                    artist: state.appData.artist,
                    composer: state.appData.composer,
                    musicGenre: state.appData.musicGenre,
                    ensembleType1: state.appData.ensembleType1,
                    // 감상 데이터
                    senseKeywords: state.appData.senseKeywords.join(', '),
                    senseText: state.appData.senseText,
                    senseColors: state.appData.senseColors.length > 0 
                        ? state.appData.senseColors.map(c => {
                            const color = COLOR_PALETTE.find(p => p.value === c);
                            return color ? `${color.name}(${color.description})` : c;
                        }).join(', ')
                        : '',
                    senseExpressionType: state.appData.senseExpressionType.join(', '),
                    senseExpressionText: state.appData.senseExpressionText,
                    senseExpressionMovement: state.appData.senseExpressionMovement ? '이미지 캡처됨' : '',
                    senseExpressionSpace: state.appData.senseExpressionSpace ? JSON.stringify(state.appData.senseExpressionSpace) : '',
                    senseExpressionPattern: state.appData.senseExpressionPattern ? '그림 생성됨' : '',
                    senseExpressionNature: state.appData.senseExpressionNature.join(', '),
                    senseExpressionPatternAnswers: JSON.stringify(state.appData.senseExpressionPatternAnswers || {}),
                    senseExpressionMovementAnswers: JSON.stringify(state.appData.senseExpressionMovementAnswers || {}),
                    senseExpressionNatureAnswers: JSON.stringify(state.appData.senseExpressionNatureAnswers || {}),
                    senseExpressionSpaceAnswers: JSON.stringify(state.appData.senseExpressionSpaceAnswers || {}),
                    senseExpressionPoetryAnswers: JSON.stringify(state.appData.senseExpressionPoetryAnswers || {}),
                    techSound: state.appData.techSound,
                    techRhythm: state.appData.techRhythm,
                    analysisHarmony: state.appData.analysisHarmony,
                    analysisForm: state.appData.analysisForm,
                    interpIntent: state.appData.interpIntent,
                    interpScene: state.appData.interpScene,
                    evalArt: state.appData.evalArt,
                    evalApply: state.appData.evalApply,
                    // AI 분석 결과
                    senseScore: state.appData.scores[0],
                    techScore: state.appData.scores[1],
                    analysisScore: state.appData.scores[2],
                    consistencyScore: state.appData.scores[3],
                    aestheticScore: state.appData.scores[4],
                    goodPoints: state.appData.feedback.goodPoints,
                    badPoints: state.appData.feedback.badPoints,
                    structuredQuestion: state.appData.feedback.structuredQuestion,
                    draftAppreciation: state.appData.feedback.draftAppreciation,
                    modelAppreciation: state.appData.feedback.modelAppreciation,
                    feedbackInput: state.feedbackInput,
                    // 최종 결과
                    finalAppreciation: state.appData.finalAppreciation,
                    performanceStrategy: state.appData.strategy.performance,
                    appreciationStrategy: state.appData.strategy.appreciation,
                    compositionStrategy: state.appData.strategy.composition
                };

                const googleFormsResult = await sendToGoogleForms(googleFormsData);
                console.log('📝 Google Forms 전송 결과:', googleFormsResult);

                state.page = 5;
            } catch (error) {
                showModal("최종 결과 생성 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
            } finally {
                state.loading = false;
                render();
            }
        }

        // =========================
        // Three.js Visualization
        // =========================
        function initVisualization(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Clear existing content
            container.innerHTML = '';

            const [sense, analysis, aesthetic] = state.appData.scores;
            const sizeFactor = 0.5 + sense / 200;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 400 / 200, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(400, 200);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            const geometry = new THREE.DodecahedronGeometry(sizeFactor * 1.5, 0);
            const color = new THREE.Color(state.appData.colors[0] || 0xcccccc);
            const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
            const structure = new THREE.Mesh(geometry, material);
            scene.add(structure);

            const detailGeometry = new THREE.TorusKnotGeometry(1.5 * sizeFactor, 0.3 * sizeFactor, 64, 8);
            const detailColor = new THREE.Color(state.appData.colors[1] || 0x888888);
            const detailMaterial = new THREE.MeshPhongMaterial({ 
                color: detailColor, 
                wireframe: true, 
                transparent: true, 
                opacity: aesthetic / 100 
            });
            const detail = new THREE.Mesh(detailGeometry, detailMaterial);
            scene.add(detail);

            camera.position.z = 5;

            function animate() {
                requestAnimationFrame(animate);
                structure.rotation.x += sense / 5000;
                structure.rotation.y += sense / 5000;
                detail.rotation.x += analysis / 15000;
                detail.rotation.y += analysis / 15000;
                renderer.render(scene, camera);
            }
            animate();

            state.visualizationScene = { renderer, scene, geometry, material, detailGeometry, detailMaterial };
        }

        // =========================
        // Modal Functions
        // =========================
        function showModal(message) {
            state.errorMessage = message;
            state.showErrorModal = true;
            render();
        }

        function closeModal() {
            state.showErrorModal = false;
            render();
        }

        // =========================
        // Navigation & Validation
        // =========================
        function handlePrevious() {
            if (state.loading) return;
            
            // 이전 페이지로 이동 (입력된 데이터는 state.appData에 유지됨)
            if (state.page > 0) {
                state.page--;
                render();
            }
        }

        async function handleNext() {
            if (state.loading) return;

            switch (state.page) {
                case 0:
                    // 학번과 이름 입력 확인
                    if (!state.studentId.trim() || !state.studentName.trim()) {
                        showModal("학번과 이름을 모두 입력해주세요.");
                        return;
                    }
                    // userId 생성 (학번과 이름 포함)
                    state.userId = `user_${Date.now()}_${state.studentId}_${state.studentName}`;
                    state.page = 1;
                    render();
                    break;
                case 1:
                    if (!state.appData.title || !state.appData.url || state.appData.senseKeywords.length === 0) {
                        showModal("악곡 제목, 유튜브 링크, 감성 키워드는 필수 입력 항목입니다.");
                        return;
                    }
                    if (state.appData.senseColors.length === 0) {
                        showModal("핵심 색상을 최소 1개 이상 선택해주세요.");
                        return;
                    }
                    state.page = 2;
                    render();
                    break;
                case 2:
                    if (!state.appData.techSound || !state.appData.techRhythm || !state.appData.analysisHarmony || !state.appData.analysisForm) {
                        showModal("2단계의 모든 항목(소리 및 음색, 속도 및 리듬, 화성 및 분위기, 형식 및 전개)을 모두 작성해주세요.");
                        return;
                    }
                    state.page = 3;
                    render();
                    break;
                case 3:
                    if (!state.appData.interpIntent || !state.appData.interpScene || !state.appData.evalArt || !state.appData.evalApply) {
                        showModal("3단계의 모든 항목(작곡 의도 및 메시지, 음악의 사회적 의미 및 역할, 예술적 가치 평가, 융합 및 확장 적용)을 모두 작성해주세요.");
                        return;
                    }
                    await generateFeedback();
                    break;
                case 4:
                    if (!state.feedbackInput) {
                        showModal("AI의 질문에 대한 보완 내용을 입력해주세요.");
                        return;
                    }
                    await generateFinalOutput(state.feedbackInput);
                    break;
                case 5:
                    // Page 5에서 완료 버튼 클릭 시 Google Forms로 데이터 전송
                    await submitToGoogleForms();
                    break;
                case 6:
                    // Page 6에서 완료 버튼 클릭 시 Page 5로 돌아가기
                    state.comparisonPageInitialized = false; // 비교 페이지 초기화 플래그 리셋
                    state.page = 5;
                    render();
                    break;
                default:
                    state.page = 1;
                    render();
            }
        }

        // =========================
        // Page Components (HTML)
        // =========================
        function renderHeader() {
            return `
                <header class="bg-gradient-to-r from-blue-600 to-indigo-700 text-white p-4 shadow-lg rounded-t-xl flex justify-between items-center">
                    <h1 class="text-2xl font-bold flex items-center">
                        ${icons.Music(24)} <span class="ml-2">소리 성찰실 (MelodyMind)</span>
                    </h1>
                    <span class="text-sm opacity-75">${state.page === 0 ? '학생 정보 입력' : `사용자 ID: ${state.userId.substring(0, 8)}...`}</span>
                </header>
            `;
        }

        function renderStepIndicator() {
            if (state.page > 3) return '';
            
            let steps = '';
            for (let i = 1; i <= 3; i++) {
                const activeClass = i === state.page 
                    ? 'bg-indigo-500 text-white shadow-lg' 
                    : 'bg-gray-200 text-gray-500';
                steps += `<div class="flex-1 text-center mx-1 py-2 rounded-full font-semibold transition-all duration-300 ${activeClass}">${i}단계</div>`;
            }
            return `<div class="flex justify-between items-center my-4">${steps}</div>`;
        }

        // 학번 입력 필터링 (숫자만)
        function filterStudentId(value) {
            return value.replace(/[^0-9]/g, '');
        }

        // 이름 입력 필터링 (한글만)
        function filterStudentName(value) {
            return value.replace(/[^가-힣\s]/g, '');
        }

        function renderPage0() {
            return `
                <div class="space-y-6">
                    <h2 class="text-xl font-semibold text-gray-700">학생 정보 입력</h2>
                    
                    <div class="bg-white p-6 rounded-lg shadow-md border border-indigo-100">
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">학번 (필수)</label>
                                <input type="text" id="studentId" value="${state.studentId}" 
                                    oninput="const filtered = filterStudentId(this.value); if (filtered !== this.value) { this.value = filtered; } state.studentId = filtered;" 
                                    onblur="render();"
                                    placeholder="예: 2024001" 
                                    pattern="[0-9]*"
                                    inputmode="numeric"
                                    class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" />
                                <p class="text-xs text-gray-500 mt-1">숫자만 입력 가능합니다.</p>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">이름 (필수)</label>
                                <input type="text" id="studentName" value="${state.studentName}" 
                                    oninput="state.studentName = this.value;" 
                                    onblur="const filtered = filterStudentName(this.value); this.value = filtered; state.studentName = filtered; render();"
                                    placeholder="예: 홍길동" 
                                    class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" />
                                <p class="text-xs text-gray-500 mt-1">한글만 입력 가능합니다. (입력 완료 후 자동으로 필터링됩니다)</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderPage1() {
            const keywords = ['기쁨', '슬픔', '긴장', '평화', '역동적', '쓸쓸함', '경쾌함', '웅장함'];
            const keywordButtons = keywords.map(keyword => {
                const isActive = state.appData.senseKeywords.includes(keyword);
                const activeClass = isActive 
                    ? 'bg-indigo-500 text-white shadow-md' 
                    : 'bg-gray-100 text-gray-600 hover:bg-indigo-100';
                return `<button onclick="toggleKeyword('${keyword}')" class="px-3 py-1 text-sm rounded-full transition-colors duration-200 ${activeClass}">${keyword}</button>`;
            }).join('');

            return `
                <div class="space-y-6">
                    <h2 class="text-xl font-semibold text-gray-700">1단계: 악곡 정보 및 감각적 감상 (반응)</h2>
                    
                    <div class="bg-white p-4 rounded-lg shadow-md border border-indigo-100">
                        <label class="block text-sm font-medium text-gray-700 mb-2">유튜브 링크 (필수)</label>
                        <input type="text" id="url" value="${state.appData.url}" oninput="updateField('url', this.value)" 
                            placeholder="https://www.youtube.com/watch?v=..." 
                            class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" />
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 bg-white p-4 rounded-lg shadow-md border border-indigo-100">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">악곡 제목</label>
                            <input type="text" id="title" value="${state.appData.title}" oninput="updateField('title', this.value)" 
                                placeholder="예: 월광 소나타" 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1" />
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">작곡가</label>
                            <input type="text" id="composer" value="${state.appData.composer}" oninput="updateField('composer', this.value)" 
                                placeholder="예: 베토벤" 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1" />
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">가수 또는 연주자 이름</label>
                            <input type="text" id="artist" value="${state.appData.artist}" oninput="updateField('artist', this.value)" 
                                placeholder="예: 랑랑" 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1" />
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">연주 형태 1 (기악/성악)</label>
                            <select id="ensembleType1" onchange="updateField('ensembleType1', this.value)" 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1">
                                <option value="">선택</option>
                                <option value="기악곡" ${state.appData.ensembleType1 === '기악곡' ? 'selected' : ''}>기악곡</option>
                                <option value="성악곡" ${state.appData.ensembleType1 === '성악곡' ? 'selected' : ''}>성악곡</option>
                                <option value="잘 모르겠음" ${state.appData.ensembleType1 === '잘 모르겠음' ? 'selected' : ''}>잘 모르겠음</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">음악 분류 (장르)</label>
                            <select id="musicGenre" onchange="updateField('musicGenre', this.value)" 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1">
                                <option value="">선택</option>
                                <option value="대중음악" ${state.appData.musicGenre === '대중음악' ? 'selected' : ''}>대중음악</option>
                                <option value="국악" ${state.appData.musicGenre === '국악' ? 'selected' : ''}>국악</option>
                                <option value="서양음악" ${state.appData.musicGenre === '서양음악' ? 'selected' : ''}>서양음악</option>
                                <option value="세계음악" ${state.appData.musicGenre === '세계음악' ? 'selected' : ''}>세계음악</option>
                                <option value="잘 모르겠음" ${state.appData.musicGenre === '잘 모르겠음' ? 'selected' : ''}>잘 모르겠음</option>
                            </select>
                        </div>
                    </div>

                    <div class="space-y-4 bg-white p-4 rounded-lg shadow-md border border-indigo-100">
                        <h3 class="font-bold text-lg text-indigo-600">감각적 감상 (1. 반응)</h3>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">감성 키워드 (2~3가지 선택)</label>
                            <div class="flex flex-wrap gap-2">
                                ${keywordButtons}
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700">느낌/분위기 서술 (50자 내외)</label>
                            <textarea id="senseText" oninput="updateField('senseText', this.value.substring(0, 50))" 
                                rows="2" placeholder="예: 이번 여름 방학 때 아빠, 엄마랑 보았던 달이 떠있던 강원도 바다가 떠올랐어요. 고요함 속에서 불안감이 느껴져요." 
                                class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.senseText}</textarea>
                            <p class="text-right text-xs text-gray-500">${state.appData.senseText.length} / 50 자</p>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">핵심 색상 (1~4개 선택)</label>
                            <div class="flex flex-wrap gap-2.5 justify-center items-center max-w-full">
                                ${COLOR_PALETTE.map(color => {
                                    const isSelected = state.appData.senseColors.includes(color.value);
                                    const isDisabled = !isSelected && state.appData.senseColors.length >= 4;
                                    const selectedClass = isSelected 
                                        ? 'border-indigo-600 scale-110 shadow-lg ring-2 ring-indigo-300' 
                                        : isDisabled
                                        ? 'border-gray-200 opacity-50 cursor-not-allowed'
                                        : 'border-gray-300 hover:scale-105';
                                    return `
                                        <button 
                                            onclick="toggleColor('${color.value}')" 
                                            ${isDisabled ? 'disabled' : ''}
                                            class="w-10 h-10 rounded-full transition-all duration-200 ${selectedClass} border-2"
                                            style="background-color: ${color.value};"
                                            title="${color.name} (${color.description})"
                                        ></button>
                                    `;
                                }).join('')}
                            </div>
                            <p class="text-center text-sm text-gray-600 mt-3">
                                ${state.appData.senseColors.length > 0 
                                    ? `선택된 색상: ${state.appData.senseColors.map(c => {
                                        const color = COLOR_PALETTE.find(p => p.value === c);
                                        return color ? `${color.name}(${color.description})` : c;
                                    }).join(', ')} (${state.appData.senseColors.length}/4)`
                                    : '색상을 1~4개 선택해주세요'}
                            </p>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">다른 방식으로 표현하기 (선택)</label>
                            <div class="space-y-2 mb-3">
                                <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                                    <input type="checkbox" 
                                        ${state.appData.senseExpressionType.includes('poetry') ? 'checked' : ''}
                                        onchange="toggleExpressionType('poetry')"
                                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <span class="text-sm">📝 시적 표현/문구 (국어)</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                                    <input type="checkbox" 
                                        ${state.appData.senseExpressionType.includes('movement') ? 'checked' : ''}
                                        onchange="toggleExpressionType('movement')"
                                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <span class="text-sm">💃 움직임/동작 (체육/무용)</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                                    <input type="checkbox" 
                                        ${state.appData.senseExpressionType.includes('nature') ? 'checked' : ''}
                                        onchange="toggleExpressionType('nature')"
                                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <span class="text-sm">⚡ 자연 현상 (과학)</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                                    <input type="checkbox" 
                                        ${state.appData.senseExpressionType.includes('space') ? 'checked' : ''}
                                        onchange="toggleExpressionType('space')"
                                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <span class="text-sm">🏞️ 공간/장소 (사회/지리)</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                                    <input type="checkbox" 
                                        ${state.appData.senseExpressionType.includes('pattern') ? 'checked' : ''}
                                        onchange="toggleExpressionType('pattern')"
                                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <span class="text-sm">🔷 도형/패턴 (수학)</span>
                                </label>
                            </div>
                            ${state.appData.senseExpressionType.length > 0 ? (() => {
                                let content = '';
                                
                                // 텍스트 입력이 필요한 방식들 (poetry)
                                const textTypes = state.appData.senseExpressionType.filter(t => t === 'poetry');
                                if (textTypes.length > 0) {
                                    content += `
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                            시적 표현/문구로 표현하기
                                        </label>
                                        <textarea id="senseExpressionText" oninput="updateField('senseExpressionText', this.value)" rows="3" 
                                            placeholder="예: 달빛에 물든 바다, 고요한 밤의 불안" 
                                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.senseExpressionText}</textarea>
                                    </div>
                                    <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded-md">
                                        <h4 class="font-semibold text-green-800 mb-3">🌙 시적 표현에 대한 질문</h4>
                                        <div class="space-y-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">시적 표현을 쓸 때 가장 먼저 떠올랐던 느낌은 무엇이었나요?</label>
                                                <textarea oninput="updateExpressionAnswer('poetry', 'firstFeeling', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="가장 먼저 떠오른 느낌을 설명해주세요.">${state.appData.senseExpressionPoetryAnswers.firstFeeling || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">음악을 어떤 장면이나 이미지로 상상했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('poetry', 'image', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="상상한 장면이나 이미지를 설명해주세요.">${state.appData.senseExpressionPoetryAnswers.image || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">시 속에서 가장 중요한 단어는 어떤 건가요? 왜 그렇게 생각했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('poetry', 'importantWord', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="가장 중요한 단어와 그 이유를 설명해주세요.">${state.appData.senseExpressionPoetryAnswers.importantWord || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">가장 마음에 드는 구절은 어디인가요? 왜 그렇게 생각하나요?</label>
                                                <textarea oninput="updateExpressionAnswer('poetry', 'favoriteLine', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="마음에 드는 구절과 그 이유를 설명해주세요.">${state.appData.senseExpressionPoetryAnswers.favoriteLine || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                    `;
                                }
                                
                                // 자연 현상 사진 선택 (nature)
                                if (state.appData.senseExpressionType.includes('nature')) {
                                    const natureImages = [
                                        { id: 'storm', name: '폭풍', emoji: '⛈️', color: '#4B5563' },
                                        { id: 'lightning', name: '번개', emoji: '⚡', color: '#FBBF24' },
                                        { id: 'rain', name: '비', emoji: '🌧️', color: '#60A5FA' },
                                        { id: 'snow', name: '눈', emoji: '❄️', color: '#E0E7FF' },
                                        { id: 'wind', name: '바람', emoji: '💨', color: '#A5B4FC' },
                                        { id: 'wave', name: '파도', emoji: '🌊', color: '#3B82F6' },
                                        { id: 'fire', name: '불', emoji: '🔥', color: '#EF4444' },
                                        { id: 'cloud', name: '구름', emoji: '☁️', color: '#9CA3AF' },
                                        { id: 'sunset', name: '일몰', emoji: '🌅', color: '#F97316' },
                                        { id: 'moon', name: '달', emoji: '🌙', color: '#FCD34D' },
                                        { id: 'star', name: '별', emoji: '⭐', color: '#FBBF24' },
                                        { id: 'ocean', name: '바다', emoji: '🌊', color: '#0EA5E9' }
                                    ];
                                    
                                    content += `
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-gray-700 mb-2">⚡ 자연 현상으로 표현하기 (2~3개 선택)</label>
                                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                                            ${natureImages.map(img => {
                                                const isSelected = state.appData.senseExpressionNature.includes(img.id);
                                                return `
                                                    <div class="cursor-pointer relative" onclick="toggleNatureImage('${img.id}')" style="user-select: none;">
                                                        <div class="border-2 rounded-lg overflow-hidden transition-all ${
                                                            isSelected 
                                                                ? 'border-indigo-600 ring-2 ring-indigo-300 scale-105 shadow-lg' 
                                                                : 'border-gray-300 hover:border-gray-400 hover:shadow-md'
                                                        }">
                                                            <div class="w-full h-24 flex items-center justify-center relative" style="background: linear-gradient(135deg, ${img.color}15 0%, ${img.color}05 100%);">
                                                                <span class="text-5xl ${isSelected ? 'opacity-100' : 'opacity-80'} transition-opacity">${img.emoji}</span>
                                                                ${isSelected ? '<div class="absolute top-1 right-1 bg-indigo-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold shadow-md">✓</div>' : ''}
                                                            </div>
                                                            <div class="p-2 text-center bg-white">
                                                                <p class="text-xs font-medium text-gray-700">${img.name}</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                        <p class="text-xs text-gray-500 mt-2">
                                            선택된 자연 현상: ${state.appData.senseExpressionNature.length > 0 
                                                ? state.appData.senseExpressionNature.map(id => natureImages.find(img => img.id === id)?.name).join(', ')
                                                : '없음'} (${state.appData.senseExpressionNature.length}/3)
                                        </p>
                                    </div>
                                    ${state.appData.senseExpressionNature.length > 0 ? `
                                    <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded-md">
                                        <h4 class="font-semibold text-green-800 mb-3">🌿 자연 현상 표현에 대한 질문</h4>
                                        <div class="space-y-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">이 자연 현상을 선택한 이유가 무엇인가요?</label>
                                                <textarea oninput="updateExpressionAnswer('nature', 'reason', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 이 음악에서 바람 소리가 나는 것 같아서 바람을 떠올렸어요.">${state.appData.senseExpressionNatureAnswers.reason || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">음악의 어떤 부분이 그 자연 현상을 생각하게 했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('nature', 'musicPart', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 이 부분은 파도가 세게 치는 느낌이었어요.">${state.appData.senseExpressionNatureAnswers.musicPart || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">선택한 자연 현상의 움직임(세기/속도)이 음악과 어떻게 닮았나요?</label>
                                                <textarea oninput="updateExpressionAnswer('nature', 'movement', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 조용해져서 눈이 내리는 느낌을 넣었어요.">${state.appData.senseExpressionNatureAnswers.movement || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">이 자연 현상을 선택하지 않았다면 어떤 다른 자연을 떠올릴 것 같나요?</label>
                                                <textarea oninput="updateExpressionAnswer('nature', 'alternative', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="다른 자연 현상을 떠올린다면...">${state.appData.senseExpressionNatureAnswers.alternative || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                    ` : ''}
                                    `;
                                }
                                
                                // 카메라 움직임 기록 (movement)
                                if (state.appData.senseExpressionType.includes('movement')) {
                                    content += `
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-gray-700 mb-2">💃 움직임/동작으로 표현하기</label>
                                        <div id="movement-container" class="border border-gray-300 rounded-md p-4 bg-gray-50">
                                            ${state.appData.senseExpressionMovement ? `
                                                <div class="mb-2">
                                                    <img src="${state.appData.senseExpressionMovement}" alt="캡처된 움직임" class="max-w-full h-auto rounded border border-gray-300" />
                                                </div>
                                                <button onclick="clearMovementCapture()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">삭제</button>
                                            ` : `
                                                <div class="text-center">
                                                    <video id="movement-video" autoplay playsinline class="hidden w-full max-w-md mx-auto rounded border border-gray-300"></video>
                                                    <canvas id="movement-canvas" class="hidden"></canvas>
                                                    <div id="movement-preview" class="hidden mb-2">
                                                        <img id="movement-preview-img" src="" alt="미리보기" class="max-w-full h-auto rounded border border-gray-300" />
                                                    </div>
                                                    <div id="movement-controls" class="space-y-2">
                                                        <button onclick="startMovementCapture()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">
                                                            📷 카메라 시작
                                                        </button>
                                                    </div>
                                                    <div id="movement-capture-controls" class="hidden space-x-2 mt-2">
                                                        <button onclick="captureMovement()" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                                                            📸 사진 촬영
                                                        </button>
                                                        <button onclick="stopMovementCapture()" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">
                                                            중지
                                                        </button>
                                                    </div>
                                                </div>
                                            `}
                                        </div>
                                    </div>
                                    ${state.appData.senseExpressionMovement ? `
                                    <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded-md">
                                        <h4 class="font-semibold text-green-800 mb-3">🕺 움직임 표현에 대한 질문</h4>
                                        <div class="space-y-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">동작에 대해 설명해 보세요.</label>
                                                <textarea oninput="updateExpressionAnswer('movement', 'description', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="동작을 자세히 설명해주세요.">${state.appData.senseExpressionMovementAnswers.description || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">왜 이 동작을 선택했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('movement', 'reason', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 이 동작은 음악이 ○○할 때 떠올라서 했어요.">${state.appData.senseExpressionMovementAnswers.reason || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">몸을 어떻게 움직였나요?</label>
                                                <textarea oninput="updateExpressionAnswer('movement', 'how', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 팔을 크게 쓴 건 소리가 세게 들렸기 때문이에요.">${state.appData.senseExpressionMovementAnswers.how || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">동작이 음악과 어떻게 연결되나요?</label>
                                                <textarea oninput="updateExpressionAnswer('movement', 'connection', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="동작과 음악의 연결점을 설명해주세요.">${state.appData.senseExpressionMovementAnswers.connection || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                    ` : ''}
                                    `;
                                }
                                
                                // 지도 공간 체크 (space)
                                if (state.appData.senseExpressionType.includes('space')) {
                                    content += `
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-gray-700 mb-2">🏞️ 공간/장소로 표현하기</label>
                                        <div class="grid grid-cols-1 ${state.appData.senseExpressionSpace ? 'lg:grid-cols-2' : ''} gap-4">
                                            <div id="space-container" class="border border-gray-300 rounded-md overflow-hidden" style="height: 400px;">
                                                ${state.appData.senseExpressionSpace ? `
                                                    <div class="p-4 bg-gray-50">
                                                        <p class="text-sm mb-2"><strong>선택한 위치:</strong></p>
                                                        <p class="text-sm text-gray-700">${state.appData.senseExpressionSpace.address || `${state.appData.senseExpressionSpace.lat.toFixed(4)}, ${state.appData.senseExpressionSpace.lng.toFixed(4)}`}</p>
                                                        <button onclick="clearSpaceSelection()" class="mt-2 px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">다시 선택</button>
                                                    </div>
                                                    <div id="space-map" style="height: 350px;"></div>
                                                ` : `
                                                    <div id="space-map" style="height: 400px;"></div>
                                                `}
                                            </div>
                                            ${state.appData.senseExpressionSpace ? `
                                                <div class="border border-gray-300 rounded-md overflow-hidden bg-gray-50">
                                                    <div class="p-4">
                                                        <h4 class="font-semibold text-gray-700 mb-2">📍 선택한 위치 상세보기</h4>
                                                        <p class="text-sm text-gray-600 mb-3">${state.appData.senseExpressionSpace.address || `${state.appData.senseExpressionSpace.lat.toFixed(4)}, ${state.appData.senseExpressionSpace.lng.toFixed(4)}`}</p>
                                                    </div>
                                                    <div id="space-detail-map" style="height: 350px;"></div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    ${state.appData.senseExpressionSpace ? `
                                    <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded-md">
                                        <h4 class="font-semibold text-green-800 mb-3">🗺️ 지도 표현에 대한 질문</h4>
                                        <div class="space-y-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">왜 이 장소를 선택했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('space', 'reason', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="장소를 선택한 이유를 설명해주세요.">${state.appData.senseExpressionSpaceAnswers.reason || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">선택한 장소와 음악이 어떻게 연결되나요?</label>
                                                <textarea oninput="updateExpressionAnswer('space', 'connection', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="장소와 음악의 연결점을 설명해주세요.">${state.appData.senseExpressionSpaceAnswers.connection || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">선택한 장소에서 이 음악이 나온다면, 어떤 장면, 상황에서 이 음악이 나오고 있을지 설명해주세요.</label>
                                                <textarea oninput="updateExpressionAnswer('space', 'scene', this.value)" rows="3" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="장면과 상황을 자세히 설명해주세요.">${state.appData.senseExpressionSpaceAnswers.scene || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                    ` : ''}
                                    `;
                                }
                                
                                // 도형/패턴 그리기 (pattern)
                                if (state.appData.senseExpressionType.includes('pattern')) {
                                    content += `
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-gray-700 mb-2">🔷 도형/패턴으로 표현하기</label>
                                        <div id="pattern-container" class="border border-gray-300 rounded-md p-4 bg-gray-50">
                                            ${state.appData.senseExpressionPattern ? `
                                                <div class="mb-2">
                                                    <img src="${state.appData.senseExpressionPattern}" alt="그린 도형" class="max-w-full h-auto rounded border border-gray-300" />
                                                </div>
                                                <button onclick="clearPatternDrawing()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">다시 그리기</button>
                                                <button onclick="editPatternDrawing()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 ml-2">수정하기</button>
                                            ` : `
                                                <div class="space-y-2">
                                                    <div class="flex gap-2 mb-2">
                                                        <button onclick="drawShape('circle')" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">원</button>
                                                        <button onclick="drawShape('rect')" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">사각형</button>
                                                        <button onclick="drawShape('triangle')" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">삼각형</button>
                                                        <button onclick="setDrawingMode('free')" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">자유 그리기</button>
                                                        <button onclick="clearPatternCanvas()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">지우기</button>
                                                        <button onclick="savePatternDrawing()" class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">저장</button>
                                                    </div>
                                                    <div class="flex gap-2 mb-2">
                                                        <input type="color" id="pattern-color" value="#3B82F6" class="h-8 w-16 border border-gray-300 rounded" />
                                                        <label class="text-sm text-gray-700 flex items-center">색상 선택</label>
                                                    </div>
                                                    <canvas id="pattern-canvas" width="600" height="400" class="border border-gray-300 rounded bg-white cursor-crosshair"></canvas>
                                                </div>
                                            `}
                                        </div>
                                    </div>
                                    ${state.appData.senseExpressionPattern ? `
                                    <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded-md">
                                        <h4 class="font-semibold text-green-800 mb-3">🎨 그림 표현에 대한 질문</h4>
                                        <div class="space-y-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">그림에서 이 색을 왜 선택했나요?</label>
                                                <textarea oninput="updateExpressionAnswer('pattern', 'colorReason', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 이 색은 음악이 ○○하게 들려서 골랐어요.">${state.appData.senseExpressionPatternAnswers.colorReason || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">음악에서 어떤 소리를 듣고 이 그림을 그렸나요?</label>
                                                <textarea oninput="updateExpressionAnswer('pattern', 'sound', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="음악의 소리와 그림의 연결을 설명해주세요.">${state.appData.senseExpressionPatternAnswers.sound || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">그림에서 가장 중요한 부분은 어디인가요?</label>
                                                <textarea oninput="updateExpressionAnswer('pattern', 'importantPart', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 여기 모양은 노래가 커지는 소리를 나타낸 거예요.">${state.appData.senseExpressionPatternAnswers.importantPart || ''}</textarea>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">왜 그 부분이 중요하다고 생각하나요?</label>
                                                <textarea oninput="updateExpressionAnswer('pattern', 'whyImportant', this.value)" rows="2" 
                                                    class="w-full p-2 border border-gray-300 rounded-md text-sm" 
                                                    placeholder="예: 이 부분을 크게 그린 건 후렴이 세게 들렸기 때문이에요.">${state.appData.senseExpressionPatternAnswers.whyImportant || ''}</textarea>
                                            </div>
                                        </div>
                                    </div>
                                    ` : ''}
                                    `;
                                }
                                
                                return content;
                            })() : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderPage2() {
            // 1단계 감각적 감상 요약 표시
            const typeNames = {
                'poetry': '📝 시적 표현/문구',
                'movement': '💃 움직임/동작',
                'nature': '⚡ 자연 현상',
                'space': '🏞️ 공간/장소',
                'pattern': '🔷 도형/패턴'
            };
            
            const natureImages = [
                { id: 'storm', name: '폭풍', emoji: '⛈️' },
                { id: 'lightning', name: '번개', emoji: '⚡' },
                { id: 'rain', name: '비', emoji: '🌧️' },
                { id: 'snow', name: '눈', emoji: '❄️' },
                { id: 'wind', name: '바람', emoji: '💨' },
                { id: 'wave', name: '파도', emoji: '🌊' },
                { id: 'fire', name: '불', emoji: '🔥' },
                { id: 'cloud', name: '구름', emoji: '☁️' },
                { id: 'sunset', name: '일몰', emoji: '🌅' },
                { id: 'moon', name: '달', emoji: '🌙' },
                { id: 'star', name: '별', emoji: '⭐' },
                { id: 'ocean', name: '바다', emoji: '🌊' }
            ];
            
            const senseSummary = `
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200 mb-4">
                    <h4 class="font-semibold text-blue-800 mb-2">📝 1단계에서 느낀 감각적 감상</h4>
                    <div class="text-sm text-gray-700 space-y-1">
                        ${state.appData.senseKeywords.length > 0 ? `<p><strong>키워드:</strong> ${state.appData.senseKeywords.join(', ')}</p>` : ''}
                        ${state.appData.senseText ? `<p><strong>느낌/분위기:</strong> ${state.appData.senseText}</p>` : ''}
                        ${state.appData.senseColors.length > 0 ? `<p><strong>색상:</strong> ${state.appData.senseColors.map(c => {
                            const color = COLOR_PALETTE.find(p => p.value === c);
                            return color ? color.name : c;
                        }).join(', ')}</p>` : ''}
                        ${state.appData.senseExpressionType.length > 0 ? `
                            <div class="mt-2 pt-2 border-t border-blue-200">
                                <p class="font-semibold text-blue-700 mb-2">다른 방식으로 표현하기:</p>
                                <div class="space-y-3">
                                    ${state.appData.senseExpressionType.map(t => {
                                        const typeName = typeNames[t] || t;
                                        let content = `<div class="bg-white p-2 rounded border border-blue-100">`;
                                        content += `<p class="font-semibold text-sm text-blue-800 mb-1">${typeName}</p>`;
                                        
                                        if (t === 'poetry') {
                                            if (state.appData.senseExpressionText) {
                                                content += `<p class="text-sm text-gray-700 italic">"${state.appData.senseExpressionText}"</p>`;
                                            } else {
                                                content += `<p class="text-xs text-gray-500">(국어 - 시적 표현/문구)</p>`;
                                            }
                                        } else if (t === 'movement') {
                                            if (state.appData.senseExpressionMovement && state.appData.senseExpressionMovement.length > 0) {
                                                content += `<div class="mt-1">
                                                    <p class="text-xs text-gray-600 mb-1">체육/무용 - 움직임/동작 이미지:</p>
                                                    <img src="${state.appData.senseExpressionMovement}" alt="움직임 표현" class="max-w-full h-auto rounded border border-gray-200" style="max-height: 200px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                                    <p class="text-xs text-red-500" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                                </div>`;
                                            } else {
                                                content += `<p class="text-xs text-gray-500">체육/무용 - 움직임/동작 이미지가 없습니다.</p>`;
                                            }
                                        } else if (t === 'space') {
                                            if (state.appData.senseExpressionSpace) {
                                                const space = state.appData.senseExpressionSpace;
                                                const location = space.address || `${space.lat.toFixed(4)}, ${space.lng.toFixed(4)}`;
                                                content += `<p class="text-sm text-gray-700">📍 ${location} (사회/지리)</p>`;
                                            } else {
                                                content += `<p class="text-xs text-gray-500">(사회/지리 - 공간/장소)</p>`;
                                            }
                                        } else if (t === 'pattern') {
                                            if (state.appData.senseExpressionPattern && state.appData.senseExpressionPattern.length > 0) {
                                                content += `<div class="mt-1">
                                                    <p class="text-xs text-gray-600 mb-1">수학 - 도형/패턴 그림:</p>
                                                    <img src="${state.appData.senseExpressionPattern}" alt="도형/패턴 표현" class="max-w-full h-auto rounded border border-gray-200" style="max-height: 200px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                                    <p class="text-xs text-red-500" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                                </div>`;
                                            } else {
                                                content += `<p class="text-xs text-gray-500">수학 - 도형/패턴 그림이 없습니다.</p>`;
                                            }
                                        } else if (t === 'nature') {
                                            if (state.appData.senseExpressionNature && state.appData.senseExpressionNature.length > 0) {
                                                const natureNames = state.appData.senseExpressionNature.map(id => {
                                                    const nature = natureImages.find(img => img.id === id);
                                                    return nature ? `${nature.emoji} ${nature.name}` : id;
                                                }).join(', ');
                                                content += `<p class="text-sm text-gray-700">${natureNames} (과학)</p>`;
                                            } else {
                                                content += `<p class="text-xs text-gray-500">(과학 - 자연 현상)</p>`;
                                            }
                                        }
                                        
                                        content += `</div>`;
                                        return content;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <p class="text-xs text-blue-600 mt-2 font-semibold">💡 위에서 느낀 감각적 감상의 <strong>근거</strong>를 아래에서 분석해보세요. "왜 그렇게 느꼈을까?"를 찾아보는 것입니다.</p>
                </div>
            `;

            return `
                <div class="space-y-6">
                    <h2 class="text-xl font-semibold text-gray-700">2단계: 분석적 감상 (2. 기술, 3. 분석)</h2>
                    
                    ${senseSummary}
                    
                    <p class="text-sm text-gray-500 bg-yellow-50 p-3 rounded-lg flex items-center">
                        ${icons.Lightbulb(16)}
                        <span class="ml-2"><strong>AI 힌트:</strong> 1단계 감상 결과, <strong>리듬 및 템포</strong> 변화에 민감하셨습니다. <strong>곡이 빨라지거나 느려지는 부분</strong>을 찾아보며 분석을 시작해 보세요.</span>
                    </p>

                    <div class="bg-white p-4 rounded-lg shadow-md border border-indigo-100 space-y-4">
                        <h3 class="font-bold text-lg text-indigo-600">2-1. 소리 및 음색 (Timbre/Dynamics)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            주도적인 악기/소리, 소리의 크기/셈여림
                            <span class="text-xs text-gray-500 font-normal">(1단계에서 느낀 소리의 특징이 어떤 악기나 셈여림 때문인지 분석해보세요)</span>
                        </label>
                        <textarea id="techSound" oninput="updateField('techSound', this.value)" rows="3" 
                            placeholder="예: 1단계에서 '어둡고 무거운 느낌'을 느꼈다면, 어떤 악기가 그 느낌을 만드는지, 소리가 크게/작게 변하는지 분석해보세요. 이 분석이 1단계에서 느낀 감각의 근거가 됩니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.techSound}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">2-2. 속도 및 리듬 (Tempo/Rhythm)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            곡의 빠르기, 반복되거나 특징적인 리듬 패턴
                            <span class="text-xs text-gray-500 font-normal">(1단계에서 느낀 빠르기나 리듬의 특징이 실제로 어떤 템포나 리듬 패턴 때문인지 분석해보세요)</span>
                        </label>
                        <textarea id="techRhythm" oninput="updateField('techRhythm', this.value)" rows="3" 
                            placeholder="예: 1단계에서 '느리다'고 느꼈다면, 실제로 곡의 템포가 어떻게 시작되고 변화하는지, 어떤 리듬이 반복되는지 분석해보세요. 이 분석이 1단계에서 느린 느낌의 근거가 됩니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.techRhythm}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">3-1. 화성 및 분위기 (Harmony/Tonality)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            곡이 밝은/어두운 느낌인지, 화음이 편안한지
                            <span class="text-xs text-gray-500 font-normal">(1단계에서 선택한 색상이나 키워드가 어떤 화음이나 조성 때문인지 분석해보세요)</span>
                        </label>
                        <textarea id="analysisHarmony" oninput="updateField('analysisHarmony', this.value)" rows="3" 
                            placeholder="예: 1단계에서 '어두운 색상'이나 '불안한 키워드'를 선택했다면, 그 느낌이 어떤 화음이나 조성에서 나오는지 분석해보세요. 이 분석이 1단계에서 느낀 분위기의 근거가 됩니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.analysisHarmony}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">3-2. 형식 및 전개 (Form/Structure)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            곡이 A-B-A처럼 나뉘는지, 반복되거나 변화하는 큰 부분
                            <span class="text-xs text-gray-500 font-normal">(1단계에서 느낀 변화나 패턴이 곡의 구조에서 어떻게 나타나는지 분석해보세요)</span>
                        </label>
                        <textarea id="analysisForm" oninput="updateField('analysisForm', this.value)" rows="3" 
                            placeholder="예: 1단계에서 '변화하는 느낌'을 느꼈다면, 곡이 어떻게 나뉘고 반복되는지, 어떤 부분에서 변화가 일어나는지 분석해보세요. 이 분석이 1단계에서 느낀 변화의 근거가 됩니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.analysisForm}</textarea>
                    </div>
                </div>
            `;
        }

        function renderPage3() {
            return `
                <div class="space-y-6">
                    <h2 class="text-xl font-semibold text-gray-700">3단계: 심미적 감상 (4. 해석, 5. 평가)</h2>
                    
                    <p class="text-sm text-gray-500 bg-yellow-50 p-3 rounded-lg flex items-center">
                        ${icons.Lightbulb(16)}
                        <span class="ml-2"><strong>AI 힌트:</strong> 2단계 분석을 바탕으로 이 곡이 당신에게 어떤 의미를 주는지, 또는 사회적 역할은 무엇인지 탐색해 보세요.</span>
                    </p>

                    <div class="bg-white p-4 rounded-lg shadow-md border border-indigo-100 space-y-4">
                        <h3 class="font-bold text-lg text-indigo-600">4-1. 작곡 의도 및 메시지 (Intent/Message)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            작곡가가 이 곡을 통해 전하고 싶었던 메시지나 의도
                            <span class="text-xs text-gray-500 font-normal">(배경 정보를 참고하여 작성: 작곡가가 이 곡으로 무엇을 말하고 싶었는지)</span>
                        </label>
                        <textarea id="interpIntent" oninput="updateField('interpIntent', this.value)" rows="3" 
                            placeholder="예: 낭만주의 시대의 초자연적 존재와 공포에 대한 관심을 반영하며, 운명적 비극을 전달한다고 해석했습니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.interpIntent}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">4-2. 음악의 사회적 의미 및 역할 (Social Meaning/Role)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            이 곡이 당시 사회나 현재 우리에게 어떤 의미를 주는지, 어떤 역할을 하는지
                            <span class="text-xs text-gray-500 font-normal">(예: 이 곡이 낭만주의 시대 사람들에게 어떤 메시지를 전달했는지, 오늘날 우리에게 어떤 의미를 주는지)</span>
                        </label>
                        <textarea id="interpScene" oninput="updateField('interpScene', this.value)" rows="3" 
                            placeholder="예: 이 곡은 낭만주의 시대의 초자연적 공포를 다루며, 당시 사람들의 불안과 두려움을 음악으로 표현했습니다. 오늘날에도 운명에 대한 두려움을 공감하게 만듭니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.interpScene}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">5-1. 예술적 가치 평가 (Aesthetic Value)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            연주자의 해석이나 작품의 예술적 완성도에 대한 나의 평가
                            <span class="text-xs text-gray-500 font-normal">(이 곡이 얼마나 예술적으로 훌륭한지, 연주가 얼마나 좋은지에 대한 평가)</span>
                        </label>
                        <textarea id="evalArt" oninput="updateField('evalArt', this.value)" rows="3" 
                            placeholder="예: 이 곡은 한 편의 짧은 오페라 같아 예술적 가치가 높으며, 연주자의 표현력이 뛰어납니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.evalArt}</textarea>

                        <h3 class="font-bold text-lg text-indigo-600">5-2. 융합 및 확장 적용 (Application/Fusion)</h3>
                        <label class="block text-sm font-medium text-gray-700 mb-1">
                            이 곡을 다른 예술(그림, 영화 등)이나 실생활에 어떻게 활용할 수 있을지
                            <span class="text-xs text-gray-500 font-normal">(이 곡을 어디에, 어떻게 사용할 수 있을지에 대한 아이디어)</span>
                        </label>
                        <textarea id="evalApply" oninput="updateField('evalApply', this.value)" rows="3" 
                            placeholder="예: 영화의 클라이맥스 BGM으로 활용하고 싶으며, 무서운 장면이나 긴장감 있는 순간에 어울릴 것 같습니다." 
                            class="w-full p-2 border border-gray-300 rounded-md mt-1">${state.appData.evalApply}</textarea>
                    </div>
                </div>
            `;
        }

        function renderPage4() {
            return `
                <div class="space-y-6">
                    <h2 class="text-xl font-semibold text-red-600 flex items-center">
                        ${icons.BarChart(20)}
                        <span class="ml-2">감상문 진단 및 보완 단계 (AI 피드백 순환)</span>
                    </h2>

                    ${state.appData.feedback.draftAppreciation ? `
                    <div class="bg-white p-4 rounded-lg shadow-md border border-blue-200">
                        <h3 class="font-bold text-lg text-blue-600 mb-3">📝 학생의 통합 감상문 초안</h3>
                        <div class="prose text-gray-800 text-sm whitespace-pre-wrap bg-blue-50 p-4 rounded-md">
                            ${state.appData.feedback.draftAppreciation}
                        </div>
                        ${(() => {
                            const natureImages = [
                                { id: 'storm', name: '폭풍', emoji: '⛈️' },
                                { id: 'lightning', name: '번개', emoji: '⚡' },
                                { id: 'rain', name: '비', emoji: '🌧️' },
                                { id: 'snow', name: '눈', emoji: '❄️' },
                                { id: 'wind', name: '바람', emoji: '💨' },
                                { id: 'wave', name: '파도', emoji: '🌊' },
                                { id: 'sun', name: '태양', emoji: '☀️' },
                                { id: 'moon', name: '달', emoji: '🌙' },
                                { id: 'cloud', name: '구름', emoji: '☁️' },
                                { id: 'fire', name: '불', emoji: '🔥' }
                            ];
                            let expressionContent = '';
                            
                            // 움직임/동작 사진 (movement)
                            if (state.appData.senseExpressionType.includes('movement') && state.appData.senseExpressionMovement) {
                                expressionContent += `
                                    <div class="mt-4 pt-4 border-t border-blue-200">
                                        <p class="text-xs font-semibold text-blue-700 mb-2">💃 움직임/동작 표현 (체육/무용)</p>
                                        <img src="${state.appData.senseExpressionMovement}" alt="움직임 표현" class="max-w-full h-auto rounded border border-gray-300" style="max-height: 300px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                        <p class="text-xs text-red-500 mt-1" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                    </div>
                                `;
                            }
                            
                            // 도형/패턴 그림 (pattern)
                            if (state.appData.senseExpressionType.includes('pattern') && state.appData.senseExpressionPattern) {
                                expressionContent += `
                                    <div class="mt-4 pt-4 border-t border-blue-200">
                                        <p class="text-xs font-semibold text-blue-700 mb-2">🔷 도형/패턴 표현 (수학)</p>
                                        <img src="${state.appData.senseExpressionPattern}" alt="도형/패턴 표현" class="max-w-full h-auto rounded border border-gray-300" style="max-height: 300px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                        <p class="text-xs text-red-500 mt-1" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                    </div>
                                `;
                            }
                            
                            return expressionContent;
                        })()}
                    </div>
                    ` : ''}

                    <div class="bg-white p-4 rounded-lg shadow-md border border-red-200 space-y-4">
                        <h3 class="font-bold text-lg text-green-600">AI 진단 - 잘된 점 (칭찬)</h3>
                        <p class="text-sm text-gray-800 bg-green-50 p-3 rounded-md">${state.appData.feedback.goodPoints}</p>

                        <h3 class="font-bold text-lg text-red-600">AI 진단 - 보완할 점 (진단)</h3>
                        <p class="text-sm text-gray-800 bg-red-50 p-3 rounded-md">${state.appData.feedback.badPoints}</p>

                        <h3 class="font-bold text-lg text-indigo-600">AI 심화 질문 (구조화된 질문)</h3>
                        <p class="text-sm font-semibold text-gray-900 bg-indigo-50 p-3 rounded-md">${state.appData.feedback.structuredQuestion}</p>
                    </div>

                    <div class="space-y-2">
                        <label class="block text-sm font-bold text-gray-700">감상문 보완 내용 직접 입력</label>
                        <textarea id="feedbackInput" oninput="state.feedbackInput = this.value" rows="5" 
                            placeholder="AI의 질문을 참고하여 감상문을 보완할 내용을 직접 입력해주세요." 
                            class="w-full p-2 border border-red-300 rounded-md focus:ring-red-500 focus:border-red-500">${state.feedbackInput}</textarea>
                    </div>
                </div>
            `;
        }

        // 레이더 차트 초기화 함수
        function initRadarChart(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 150;
            
            const labels = ['감각적\n민감도', '기술적\n정확도', '분석적\n이해도', '논리적\n일관성', '심미적\n통찰력'];
            const scores = state.appData.scores;
            const maxScore = 100;
            
            // 배경 그리기
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            // 동심원 그리기 (5개)
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (radius * i) / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 축 그리기 (5개)
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // 라벨 그리기
                const labelX = centerX + Math.cos(angle) * (radius + 30);
                const labelY = centerY + Math.sin(angle) * (radius + 30);
                ctx.fillStyle = '#374151';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // 데이터 영역 그리기
            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.strokeStyle = '#3B82F6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                const score = scores[i] || 50;
                const distance = (radius * score) / maxScore;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // 점 그리기
            ctx.fillStyle = '#3B82F6';
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                const score = scores[i] || 50;
                const distance = (radius * score) / maxScore;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 점수 표시
                ctx.fillStyle = '#1F2937';
                ctx.font = '11px Inter';
                ctx.fillText(`${score}점`, x + 15, y);
                ctx.fillStyle = '#3B82F6';
            }
        }

        // =========================
        // 클라우드 시각화 함수들
        // =========================

        // 1. 키워드 워드 클라우드 생성
        function createKeywordCloud(studentsData, containerId) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('워드 클라우드 컨테이너를 찾을 수 없습니다:', containerId);
                return;
            }
            
            console.log('워드 클라우드 생성 시작, 학생 데이터:', studentsData);
            
            // 모든 학생의 키워드를 수집하고 빈도 계산
            const keywordFrequency = {};
            studentsData.forEach((student, index) => {
                console.log(`학생 ${index + 1} 키워드:`, student.senseKeywords);
                if (student.senseKeywords && Array.isArray(student.senseKeywords)) {
                    student.senseKeywords.forEach(keyword => {
                        const trimmed = keyword.trim();
                        if (trimmed) {
                            keywordFrequency[trimmed] = (keywordFrequency[trimmed] || 0) + 1;
                        }
                    });
                } else if (student.senseKeywords && typeof student.senseKeywords === 'string') {
                    // 문자열인 경우 쉼표로 분리
                    student.senseKeywords.split(',').forEach(keyword => {
                        const trimmed = keyword.trim();
                        if (trimmed) {
                            keywordFrequency[trimmed] = (keywordFrequency[trimmed] || 0) + 1;
                        }
                    });
                }
            });
            
            console.log('키워드 빈도:', keywordFrequency);
            
            if (Object.keys(keywordFrequency).length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center py-8">키워드 데이터가 없습니다.</p>';
                return;
            }
            
            // wordcloud2.js 형식으로 변환
            const wordList = Object.entries(keywordFrequency)
                .map(([text, weight]) => ({
                    text,
                    size: Math.max(20, weight * 15) // 최소 20px, 빈도에 따라 크기 조정
                }))
                .sort((a, b) => b.size - a.size); // 크기 순 정렬
            
            // 간단한 텍스트 기반 워드 클라우드 생성 (wordcloud2.js 오류 대신)
            container.innerHTML = '';
            
            // 키워드를 빈도순으로 정렬
            const sortedKeywords = Object.entries(keywordFrequency)
                .sort((a, b) => b[1] - a[1]);
            
            const maxFrequency = Math.max(...sortedKeywords.map(([_, freq]) => freq));
            
            // 워드 클라우드 HTML 생성
            const cloudHTML = `
                <div class="flex flex-wrap items-center justify-center gap-3 p-6 bg-white rounded-lg border border-gray-200">
                    ${sortedKeywords.map(([keyword, frequency]) => {
                        // 빈도에 따라 크기와 색상 결정
                        const sizeRatio = frequency / maxFrequency;
                        const fontSize = Math.max(16, Math.min(48, 20 + sizeRatio * 28));
                        const opacity = 0.6 + sizeRatio * 0.4;
                        const hue = 220 - sizeRatio * 40;
                        
                        return `
                            <span 
                                class="inline-block px-3 py-1 rounded-full font-semibold transition-transform hover:scale-110 cursor-default"
                                style="font-size: ${fontSize}px; color: hsl(${hue}, 70%, ${50 - sizeRatio * 20}%); opacity: ${opacity};"
                                title="${keyword}: ${frequency}회"
                            >
                                ${keyword}
                                <span class="text-xs ml-1 opacity-70">(${frequency})</span>
                            </span>
                        `;
                    }).join('')}
                </div>
            `;
            
            container.innerHTML = cloudHTML;
            
            // wordcloud2.js는 오류가 많아서 HTML/CSS 버전만 사용
            // 필요시 수동으로 새로고침 버튼을 눌러 최신 데이터 확인
        }

        // 2. 색상 분포 시각화
        function createColorDistribution(studentsData, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // 색상 빈도 계산 (색상 값 기준)
            const colorFrequency = {};
            studentsData.forEach(student => {
                if (student.senseColors && Array.isArray(student.senseColors)) {
                    student.senseColors.forEach(color => {
                        const trimmed = color.trim();
                        if (trimmed) {
                            colorFrequency[trimmed] = (colorFrequency[trimmed] || 0) + 1;
                        }
                    });
                }
            });
            
            if (Object.keys(colorFrequency).length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center py-8">색상 데이터가 없습니다.</p>';
                return;
            }
            
            // 색상 팔레트에서 이름 찾기
            const colorData = Object.entries(colorFrequency)
                .map(([colorValue, count]) => {
                    // 색상 값에서 실제 hex 색상 추출
                    let actualColorValue = colorValue;
                    let colorInfo = COLOR_PALETTE.find(p => colorValue.includes(p.value));
                    
                    // "파랑(평화, 고요)" 형식에서 색상 이름으로 찾기
                    if (!colorInfo) {
                        colorInfo = COLOR_PALETTE.find(p => colorValue.includes(p.name));
                        if (colorInfo) {
                            actualColorValue = colorInfo.value;
                        }
                    } else {
                        actualColorValue = colorInfo.value;
                    }
                    
                    return {
                        value: actualColorValue,
                        name: colorInfo ? colorInfo.name : colorValue,
                        description: colorInfo ? colorInfo.description : '',
                        count: count,
                        percentage: ((count / studentsData.length) * 100).toFixed(1)
                    };
                })
                .sort((a, b) => b.count - a.count);
            
            // 시각화 HTML 생성
            container.innerHTML = `
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    ${colorData.map(color => `
                        <div class="bg-white p-4 rounded-lg shadow-md border-2 transition-transform hover:scale-105" 
                             style="border-color: ${color.value};">
                            <div class="flex items-center gap-3 mb-2">
                                <div class="w-12 h-12 rounded-full shadow-md" 
                                     style="background-color: ${color.value};"></div>
                                <div class="flex-1">
                                    <div class="font-semibold text-gray-800">${color.name}</div>
                                    <div class="text-xs text-gray-500">${color.description}</div>
                                </div>
                            </div>
                            <div class="text-sm text-gray-600">
                                <div class="font-bold text-indigo-600 text-lg">${color.count}명</div>
                                <div class="text-xs text-gray-400">전체의 ${color.percentage}%</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // 3. 통계 요약 생성
        function createStatistics(studentsData, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const totalStudents = studentsData.length;
            const uniqueMusics = new Set(
                studentsData.map(s => `${s.title || '미입력'} - ${s.composer || '미입력'}`)
            ).size;
            
            const avgScores = {
                sense: 0,
                tech: 0,
                analysis: 0,
                consistency: 0,
                aesthetic: 0
            };
            
            let scoreCount = 0;
            studentsData.forEach(s => {
                if (s.scores) {
                    avgScores.sense += s.scores.senseScore || 0;
                    avgScores.tech += s.scores.techScore || 0;
                    avgScores.analysis += s.scores.analysisScore || 0;
                    avgScores.consistency += s.scores.consistencyScore || 0;
                    avgScores.aesthetic += s.scores.aestheticScore || 0;
                    scoreCount++;
                }
            });
            
            if (scoreCount > 0) {
                Object.keys(avgScores).forEach(key => {
                    avgScores[key] = (avgScores[key] / scoreCount).toFixed(1);
                });
            }
            
            container.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <div class="text-sm text-blue-600 font-medium">총 학생 수</div>
                        <div class="text-3xl font-bold text-blue-700 mt-2">${totalStudents}명</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                        <div class="text-sm text-green-600 font-medium">감상한 악곡 수</div>
                        <div class="text-3xl font-bold text-green-700 mt-2">${uniqueMusics}곡</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                        <div class="text-sm text-purple-600 font-medium">평균 감각적 민감도</div>
                        <div class="text-3xl font-bold text-purple-700 mt-2">${avgScores.sense}점</div>
                    </div>
                </div>
            `;
        }

        // 4. 학생 데이터 가져오기
        async function fetchStudentsData(filters = {}) {
            try {
                let url = `${API_BASE_URL}/api/students-data`;
                const params = new URLSearchParams();
                
                if (filters.title) params.append('title', filters.title);
                if (filters.composer) params.append('composer', filters.composer);
                if (filters.limit) params.append('limit', filters.limit);
                
                if (params.toString()) {
                    url += '?' + params.toString();
                }
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    cache: 'no-cache'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    return data.students || [];
                } else {
                    console.error('데이터 가져오기 실패:', data.error);
                    return [];
                }
            } catch (error) {
                // 오류를 한 번만 로그로 출력
                if (!window._fetchErrorLogged) {
                    console.error('학생 데이터 가져오기 실패:', error.message);
                    window._fetchErrorLogged = true;
                    setTimeout(() => { window._fetchErrorLogged = false; }, 5000); // 5초 후 리셋
                }
                return [];
            }
        }

        // 5. 비교 페이지 렌더링
        function renderComparisonPage() {
            return `
                <div class="space-y-6">
                    <h2 class="text-2xl font-bold text-indigo-700 flex items-center">
                        ${icons.BarChart(24)}
                        <span class="ml-2">📊 감각적 감상 비교 분석</span>
                    </h2>
                    
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">💡</span>
                                <div>
                                    <p class="text-sm font-semibold text-blue-800">실시간 데이터 업데이트</p>
                                    <p class="text-xs text-blue-600">학생들이 완료 버튼을 누르면 자동으로 데이터가 수집됩니다. 새로고침 버튼을 눌러 최신 데이터를 확인하세요.</p>
                                </div>
                            </div>
                            <button onclick="refreshComparison()" 
                                    class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors text-sm font-semibold shadow-md">
                                🔄 새로고침
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-semibold text-gray-700">키워드 클라우드</h3>
                            <span class="text-sm text-gray-500" id="data-count-info">로딩 중...</span>
                        </div>
                        <div id="keyword-cloud-container" class="w-full flex justify-center items-center bg-gray-50 p-4 rounded-lg min-h-[500px]"></div>
                    </div>
                    
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-semibold text-gray-700 mb-4">색상 분포</h3>
                        <div id="color-distribution-container"></div>
                    </div>
                    
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-semibold text-gray-700 mb-4">통계 요약</h3>
                        <div id="statistics-container"></div>
                    </div>
                </div>
            `;
        }

        // 6. 비교 페이지 초기화
        async function initComparisonPage() {
            // 중복 호출 방지
            if (state.loading || state.comparisonPageInitialized) {
                console.log('이미 초기화 중이거나 완료되었습니다. 중복 호출을 건너뜁니다.');
                return;
            }
            
            state.loading = true;
            state.comparisonPageInitialized = true; // 초기화 시작 표시
            
            // render() 호출하지 않고 직접 DOM 업데이트
            const container = document.getElementById('keyword-cloud-container');
            if (container) {
                container.innerHTML = '<p class="text-gray-500 text-center py-8">데이터를 불러오는 중...</p>';
            }
            
            const studentsData = await fetchStudentsData();
            
            if (studentsData.length === 0) {
                // 데이터가 없을 때 더 명확한 안내 메시지
                const container = document.getElementById('keyword-cloud-container');
                if (container) {
                    container.innerHTML = `
                        <div class="w-full text-center py-12">
                            <div class="text-6xl mb-4">📭</div>
                            <h3 class="text-xl font-semibold text-gray-700 mb-2">아직 제출된 데이터가 없습니다</h3>
                            <p class="text-gray-500 mb-4">
                                학생들이 감상문을 작성하고 <strong>완료 버튼</strong>을 눌러야<br>
                                비교 분석 데이터가 수집됩니다.
                            </p>
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-left max-w-md mx-auto text-sm text-gray-700">
                                <p class="font-semibold mb-2">📋 데이터 수집 방법:</p>
                                <ol class="list-decimal list-inside space-y-1">
                                    <li>학생이 1~3단계 감상 입력</li>
                                    <li>AI 진단 및 보완 내용 입력</li>
                                    <li>최종 감상문 완성</li>
                                    <li><strong>완료 버튼 클릭</strong> ← 이 단계에서 데이터 저장</li>
                                </ol>
                            </div>
                            <button onclick="refreshComparison()" 
                                    class="mt-6 px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-semibold">
                                🔄 새로고침
                            </button>
                        </div>
                    `;
                }
                
                const colorContainer = document.getElementById('color-distribution-container');
                if (colorContainer) {
                    colorContainer.innerHTML = '<p class="text-gray-500 text-center py-8">데이터가 없습니다.</p>';
                }
                
                const statsContainer = document.getElementById('statistics-container');
                if (statsContainer) {
                    statsContainer.innerHTML = '<p class="text-gray-500 text-center py-8">데이터가 없습니다.</p>';
                }
                
                state.loading = false;
                state.comparisonPageInitialized = false; // 실패 시 플래그 리셋
                return;
            }
            
            createKeywordCloud(studentsData, 'keyword-cloud-container');
            createColorDistribution(studentsData, 'color-distribution-container');
            createStatistics(studentsData, 'statistics-container');
            
            // 데이터 개수 표시 업데이트
            const countInfo = document.getElementById('data-count-info');
            if (countInfo) {
                countInfo.textContent = `총 ${studentsData.length}명의 데이터`;
            }
            
            state.loading = false;
            // render() 호출하지 않음 - 무한 루프 방지
        }

        // 7. 새로고침 함수
        async function refreshComparison() {
            if (state.loading) {
                console.log('이미 로딩 중입니다. 새로고침을 건너뜁니다.');
                return;
            }
            await initComparisonPage();
        }

        function renderPage5() {
            // Initialize radar chart after render
            setTimeout(() => initRadarChart('radar-chart-container'), 100);

            return `
                <div class="space-y-6">
                    <h2 class="text-2xl font-bold text-indigo-700 flex items-center">
                        ${icons.Feather(24)}
                        <span class="ml-2">최종 감상 보고서 및 활용 전략</span>
                    </h2>

                    <h3 class="text-xl font-semibold text-gray-700">1. 감상 능력 지표 시각화 (AI 분석 결과)</h3>
                    <div id="radar-chart-container" class="w-full flex justify-center items-center bg-white p-4 rounded-xl shadow-lg border border-indigo-200"></div>
                    
                    <div class="grid grid-cols-5 gap-2 text-center text-xs font-semibold text-gray-700 bg-gray-100 p-2 rounded-lg">
                        <div class="flex flex-col items-center justify-center">
                            ${icons.Eye(14)}
                            <span class="mt-1">감각적<br>민감도</span>
                            <span class="text-indigo-600 font-bold">${state.appData.scores[0]}점</span>
                        </div>
                        <div class="flex flex-col items-center justify-center">
                            ${icons.Gauge(14)}
                            <span class="mt-1">기술적<br>정확도</span>
                            <span class="text-indigo-600 font-bold">${state.appData.scores[1]}점</span>
                        </div>
                        <div class="flex flex-col items-center justify-center">
                            ${icons.BarChart(14)}
                            <span class="mt-1">분석적<br>이해도</span>
                            <span class="text-indigo-600 font-bold">${state.appData.scores[2]}점</span>
                        </div>
                        <div class="flex flex-col items-center justify-center">
                            ${icons.MessageCircle(14)}
                            <span class="mt-1">논리적<br>일관성</span>
                            <span class="text-indigo-600 font-bold">${state.appData.scores[3]}점</span>
                        </div>
                        <div class="flex flex-col items-center justify-center">
                            ${icons.Lightbulb(14)}
                            <span class="mt-1">심미적<br>통찰력</span>
                            <span class="text-indigo-600 font-bold">${state.appData.scores[4]}점</span>
                        </div>
                    </div>

                    <div class="space-y-4">
                        <h3 class="text-xl font-semibold text-indigo-600">2. 감상문 비교</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-white p-4 rounded-lg shadow-md border border-indigo-200">
                                <h4 class="font-bold text-lg text-indigo-600 mb-2">📝 학생의 보완된 최종 감상문</h4>
                                <div class="prose text-gray-800 text-sm whitespace-pre-wrap max-h-96 overflow-y-auto">
                                    ${state.appData.finalAppreciation || "최종 감상문 생성 중 오류가 발생했거나 데이터가 없습니다."}
                                </div>
                                ${(() => {
                                    const natureImages = [
                                        { id: 'storm', name: '폭풍', emoji: '⛈️' },
                                        { id: 'lightning', name: '번개', emoji: '⚡' },
                                        { id: 'rain', name: '비', emoji: '🌧️' },
                                        { id: 'snow', name: '눈', emoji: '❄️' },
                                        { id: 'wind', name: '바람', emoji: '💨' },
                                        { id: 'wave', name: '파도', emoji: '🌊' },
                                        { id: 'sun', name: '태양', emoji: '☀️' },
                                        { id: 'moon', name: '달', emoji: '🌙' },
                                        { id: 'cloud', name: '구름', emoji: '☁️' },
                                        { id: 'fire', name: '불', emoji: '🔥' }
                                    ];
                                    let expressionContent = '';
                                    
                                    // 움직임/동작 사진 (movement)
                                    if (state.appData.senseExpressionType.includes('movement') && state.appData.senseExpressionMovement) {
                                        expressionContent += `
                                            <div class="mt-4 pt-4 border-t border-indigo-200">
                                                <p class="text-xs font-semibold text-indigo-700 mb-2">💃 움직임/동작 표현 (체육/무용)</p>
                                                <img src="${state.appData.senseExpressionMovement}" alt="움직임 표현" class="max-w-full h-auto rounded border border-gray-300" style="max-height: 300px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                                <p class="text-xs text-red-500 mt-1" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                            </div>
                                        `;
                                    }
                                    
                                    // 도형/패턴 그림 (pattern)
                                    if (state.appData.senseExpressionType.includes('pattern') && state.appData.senseExpressionPattern) {
                                        expressionContent += `
                                            <div class="mt-4 pt-4 border-t border-indigo-200">
                                                <p class="text-xs font-semibold text-indigo-700 mb-2">🔷 도형/패턴 표현 (수학)</p>
                                                <img src="${state.appData.senseExpressionPattern}" alt="도형/패턴 표현" class="max-w-full h-auto rounded border border-gray-300" style="max-height: 300px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                                                <p class="text-xs text-red-500 mt-1" style="display:none;">이미지를 불러올 수 없습니다.</p>
                                            </div>
                                        `;
                                    }
                                    
                                    return expressionContent;
                                })()}
                            </div>
                            <div class="bg-white p-4 rounded-lg shadow-md border border-green-200">
                                <h4 class="font-bold text-lg text-green-600 mb-2">⭐ 모범 감상문 예시</h4>
                                <div class="prose text-gray-800 text-sm whitespace-pre-wrap max-h-96 overflow-y-auto bg-green-50 p-3 rounded">
                                    ${state.appData.feedback.modelAppreciation || "모범 감상문이 생성되지 않았습니다."}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-3 bg-white p-4 rounded-lg shadow-md border border-green-200">
                        <h3 class="text-xl font-semibold text-green-600">3. 미래 활동 연계 활용 전략</h3>
                        <div class="text-sm space-y-2">
                            <p><strong class="text-blue-700">▶ 연주 전략:</strong> ${state.appData.strategy.performance}</p>
                            <p><strong class="text-blue-700">▶ 감상 전략:</strong> ${state.appData.strategy.appreciation}</p>
                            <p><strong class="text-blue-700">▶ 창작 전략:</strong> ${state.appData.strategy.composition}</p>
                        </div>
                    </div>
                    
                    <div class="text-center mt-6">
                        <button onclick="state.page = 6; render();" 
                                class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-semibold shadow-lg">
                            📊 전체 비교 분석 보기
                        </button>
                    </div>
                </div>
            `;
        }

        function renderFooter() {
            const buttonText = state.loading ? "AI 분석 중..." : 
                state.page === 0 ? "다음 단계로 이동" :
                state.page === 1 || state.page === 2 ? "다음 단계로 이동" :
                state.page === 3 ? "AI 진단 시작" :
                state.page === 4 ? "최종 감상문 완성" :
                state.page === 6 ? "최종 감상문으로 돌아가기" :
                "완료";
            
            const disabled = state.loading;
            const buttonClass = disabled 
                ? 'bg-gray-400' 
                : 'bg-indigo-600 hover:bg-indigo-700 shadow-xl';
            
            // 이전 버튼 표시 여부 (1, 2, 3단계에서만)
            const showPrevButton = state.page >= 1 && state.page <= 3;

            return `
                <footer class="fixed bottom-0 left-0 right-0 max-w-4xl mx-auto bg-white p-4 border-t shadow-2xl">
                    <div class="flex gap-3">
                        ${showPrevButton ? `
                            <button onclick="handlePrevious()" ${disabled ? 'disabled' : ''} 
                                class="py-3 px-6 rounded-lg font-bold text-gray-700 bg-gray-200 hover:bg-gray-300 transition-colors duration-300 ${disabled ? 'opacity-50' : ''}">
                                ← 이전
                            </button>
                        ` : ''}
                        <button onclick="handleNext()" ${disabled ? 'disabled' : ''} 
                            class="${showPrevButton ? 'flex-1' : 'w-full'} py-3 px-4 rounded-lg font-bold text-white transition-colors duration-300 ${buttonClass}">
                            ${buttonText}
                        </button>
                    </div>
                </footer>
            `;
        }

        function renderModal() {
            if (!state.showErrorModal) return '';
            
            return `
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                    <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full space-y-4">
                        <h3 class="text-xl font-bold text-red-600 flex items-center">
                            ${icons.X(20)}
                            <span class="ml-2">오류 발생</span>
                        </h3>
                        <p class="text-gray-700">${state.errorMessage}</p>
                        <button onclick="closeModal()" 
                            class="w-full py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                            닫기
                        </button>
                    </div>
                </div>
            `;
        }

        // =========================
        // Main Render Function
        // =========================
        function render() {
            const pageContent = 
                state.page === 0 ? renderPage0() :
                state.page === 1 ? renderPage1() :
                state.page === 2 ? renderPage2() :
                state.page === 3 ? renderPage3() :
                state.page === 4 ? renderPage4() :
                state.page === 5 ? renderPage5() :
                state.page === 6 ? renderComparisonPage() :
                '<div>알 수 없는 페이지</div>';
            
            // Page 6 초기화 (한 번만 실행)
            if (state.page === 6 && !state.comparisonPageInitialized) {
                // 페이지가 6으로 변경되었고 아직 초기화되지 않았을 때만 실행
                setTimeout(() => initComparisonPage(), 100);
            } else if (state.page !== 6) {
                // 다른 페이지로 이동하면 초기화 플래그 리셋
                state.comparisonPageInitialized = false;
            }

            const html = `
                <div class="max-w-4xl mx-auto p-4 sm:p-6 bg-gray-50 rounded-xl shadow-2xl min-h-screen">
                    ${renderHeader()}
                    ${renderStepIndicator()}
                    <div class="mt-4 pb-24">
                        ${pageContent}
                    </div>
                    ${renderFooter()}
                    ${renderModal()}
                </div>
            `;

            document.getElementById('app').innerHTML = html;
            
            // 페이지 렌더링 후 각 기능 초기화
            if (state.page === 1) {
                setTimeout(() => {
                    // 지도 초기화
                    if (state.appData.senseExpressionType.includes('space')) {
                        initSpaceMap();
                    }
                    // 도형 그리기 캔버스 초기화
                    if (state.appData.senseExpressionType.includes('pattern')) {
                        initPatternCanvas();
                    }
                }, 100);
            }
        }

        // =========================
        // Event Handlers (Global)
        // =========================
        function updateField(field, value) {
            state.appData[field] = value;
        }

        function updateExpressionAnswer(type, questionKey, value) {
            if (!state.appData[`senseExpression${type.charAt(0).toUpperCase() + type.slice(1)}Answers`]) {
                state.appData[`senseExpression${type.charAt(0).toUpperCase() + type.slice(1)}Answers`] = {};
            }
            state.appData[`senseExpression${type.charAt(0).toUpperCase() + type.slice(1)}Answers`][questionKey] = value;
            render();
        }

        function toggleKeyword(keyword) {
            const idx = state.appData.senseKeywords.indexOf(keyword);
            if (idx > -1) {
                state.appData.senseKeywords.splice(idx, 1);
            } else {
                if (state.appData.senseKeywords.length < 3) {
                    state.appData.senseKeywords.push(keyword);
                }
            }
            render();
        }

        function toggleColor(colorValue) {
            const idx = state.appData.senseColors.indexOf(colorValue);
            if (idx > -1) {
                // 이미 선택된 색상이면 제거
                state.appData.senseColors.splice(idx, 1);
            } else {
                // 최대 4개까지 선택 가능
                if (state.appData.senseColors.length < 4) {
                    state.appData.senseColors.push(colorValue);
                }
            }
            render();
        }

        function toggleExpressionType(type) {
            const idx = state.appData.senseExpressionType.indexOf(type);
            if (idx > -1) {
                // 이미 선택된 타입이면 제거
                state.appData.senseExpressionType.splice(idx, 1);
                // 선택된 타입이 없으면 텍스트도 초기화
                if (state.appData.senseExpressionType.length === 0) {
                    state.appData.senseExpressionText = '';
                }
                // 각 타입별 데이터도 초기화
                if (type === 'movement') state.appData.senseExpressionMovement = null;
                if (type === 'space') state.appData.senseExpressionSpace = null;
                if (type === 'pattern') state.appData.senseExpressionPattern = null;
            } else {
                // 최대 2개까지 선택 가능
                if (state.appData.senseExpressionType.length < 2) {
                    state.appData.senseExpressionType.push(type);
                } else {
                    alert('표현 방식은 최대 2개까지 선택할 수 있습니다.');
                    // 체크박스 상태를 원래대로 되돌리기 위해 다시 렌더링
                    render();
                    return;
                }
            }
            render();
            // 렌더링 후 각 기능 초기화
            setTimeout(() => {
                if (state.appData.senseExpressionType.includes('space')) {
                    initSpaceMap();
                }
                if (state.appData.senseExpressionType.includes('pattern')) {
                    initPatternCanvas();
                }
            }, 100);
        }

        // =========================
        // 자연 현상 이미지 선택 기능
        // =========================
        function toggleNatureImage(imageId) {
            const idx = state.appData.senseExpressionNature.indexOf(imageId);
            if (idx > -1) {
                // 이미 선택된 이미지면 제거
                state.appData.senseExpressionNature.splice(idx, 1);
            } else {
                // 최대 3개까지 선택 가능
                if (state.appData.senseExpressionNature.length < 3) {
                    state.appData.senseExpressionNature.push(imageId);
                } else {
                    alert('자연 현상은 최대 3개까지 선택할 수 있습니다.');
                    return;
                }
            }
            render();
        }

        // =========================
        // 카메라 움직임 기록 기능
        // =========================
        let movementStream = null;

        async function startMovementCapture() {
            try {
                const video = document.getElementById('movement-video');
                const controls = document.getElementById('movement-controls');
                const captureControls = document.getElementById('movement-capture-controls');
                
                if (!video) return;
                
                movementStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user' } 
                });
                video.srcObject = movementStream;
                video.classList.remove('hidden');
                controls.classList.add('hidden');
                captureControls.classList.remove('hidden');
            } catch (error) {
                alert('카메라 접근 권한이 필요합니다. 브라우저 설정에서 카메라 권한을 허용해주세요.');
                console.error('카메라 접근 오류:', error);
            }
        }

        function captureMovement() {
            const video = document.getElementById('movement-video');
            const canvas = document.getElementById('movement-canvas');
            const preview = document.getElementById('movement-preview');
            const previewImg = document.getElementById('movement-preview-img');
            
            if (!video || !canvas) return;
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            const imageData = canvas.toDataURL('image/png');
            state.appData.senseExpressionMovement = imageData;
            
            previewImg.src = imageData;
            preview.classList.remove('hidden');
            video.classList.add('hidden');
            
            render();
        }

        function stopMovementCapture() {
            if (movementStream) {
                movementStream.getTracks().forEach(track => track.stop());
                movementStream = null;
            }
            const video = document.getElementById('movement-video');
            const controls = document.getElementById('movement-controls');
            const captureControls = document.getElementById('movement-capture-controls');
            
            if (video) video.classList.add('hidden');
            if (controls) controls.classList.remove('hidden');
            if (captureControls) captureControls.classList.add('hidden');
        }

        function clearMovementCapture() {
            state.appData.senseExpressionMovement = null;
            stopMovementCapture();
            render();
        }

        // =========================
        // 지도 공간 체크 기능
        // =========================
        let spaceMap = null;
        let spaceMarker = null;

        let spaceDetailMap = null;

        function initSpaceMap() {
            const mapContainer = document.getElementById('space-map');
            if (!mapContainer) return;
            
            // 기존 맵이 있으면 제거
            if (spaceMap) {
                spaceMap.remove();
                spaceMap = null;
                spaceMarker = null;
            }
            
            // 기본 위치: 서울
            const defaultLat = state.appData.senseExpressionSpace?.lat || 37.5665;
            const defaultLng = state.appData.senseExpressionSpace?.lng || 126.9780;
            
            spaceMap = L.map('space-map').setView([defaultLat, defaultLng], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(spaceMap);
            
            // 기존 선택 위치가 있으면 마커 표시
            if (state.appData.senseExpressionSpace) {
                spaceMarker = L.marker([defaultLat, defaultLng]).addTo(spaceMap);
                // 상세 지도도 초기화
                initSpaceDetailMap();
            }
            
            // 지도 클릭 시 위치 선택
            spaceMap.on('click', async (e) => {
                const { lat, lng } = e.latlng;
                
                // 기존 마커 제거
                if (spaceMarker) {
                    spaceMap.removeLayer(spaceMarker);
                }
                
                // 새 마커 추가
                spaceMarker = L.marker([lat, lng]).addTo(spaceMap);
                
                // 주소 가져오기 (간단한 역지오코딩)
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`);
                    const data = await response.json();
                    const address = data.display_name || `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
                    
                    state.appData.senseExpressionSpace = { lat, lng, address };
                } catch (error) {
                    state.appData.senseExpressionSpace = { lat, lng, address: `${lat.toFixed(4)}, ${lng.toFixed(4)}` };
                }
                
                render();
                setTimeout(() => {
                    initSpaceMap();
                }, 100);
            });
        }

        function initSpaceDetailMap() {
            const detailMapContainer = document.getElementById('space-detail-map');
            if (!detailMapContainer || !state.appData.senseExpressionSpace) return;
            
            // 기존 상세 지도 제거
            if (spaceDetailMap) {
                spaceDetailMap.remove();
                spaceDetailMap = null;
            }
            
            const { lat, lng } = state.appData.senseExpressionSpace;
            
            // 확대된 상세 지도 (줌 레벨 18로 매우 확대)
            spaceDetailMap = L.map('space-detail-map').setView([lat, lng], 18);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(spaceDetailMap);
            
            // 마커 추가
            L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(spaceDetailMap);
            
            // 원형 반경 표시 (100m 반경)
            L.circle([lat, lng], {
                color: '#3388ff',
                fillColor: '#3388ff',
                fillOpacity: 0.2,
                radius: 100
            }).addTo(spaceDetailMap);
        }

        function clearSpaceSelection() {
            state.appData.senseExpressionSpace = null;
            if (spaceMap) {
                spaceMap.remove();
                spaceMap = null;
            }
            if (spaceDetailMap) {
                spaceDetailMap.remove();
                spaceDetailMap = null;
            }
            spaceMarker = null;
            render();
        }

        // =========================
        // 도형/패턴 그리기 기능
        // =========================
        let patternCanvas = null;
        let patternCtx = null;
        let isDrawing = false;
        let currentShape = null;
        let startX = 0, startY = 0;

        function initPatternCanvas() {
            const canvas = document.getElementById('pattern-canvas');
            if (!canvas) return;
            
            // 기존 이벤트 리스너 제거 후 재등록
            if (patternCanvas && patternCanvas !== canvas) {
                patternCanvas.removeEventListener('mousedown', startDrawing);
                patternCanvas.removeEventListener('mousemove', draw);
                patternCanvas.removeEventListener('mouseup', stopDrawing);
                patternCanvas.removeEventListener('mouseout', stopDrawing);
            }
            
            patternCanvas = canvas;
            patternCtx = canvas.getContext('2d');
            
            // 기존 이미지가 있으면 로드
            if (state.appData.senseExpressionPattern) {
                const img = new Image();
                img.onload = () => {
                    patternCtx.clearRect(0, 0, canvas.width, canvas.height);
                    patternCtx.drawImage(img, 0, 0);
                };
                img.src = state.appData.senseExpressionPattern;
            }
            
            // 마우스 이벤트 (중복 방지)
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', draw);
            canvas.removeEventListener('mouseup', stopDrawing);
            canvas.removeEventListener('mouseout', stopDrawing);
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
        }

        function editPatternDrawing() {
            state.appData.senseExpressionPattern = null;
            render();
            setTimeout(() => {
                initPatternCanvas();
            }, 100);
        }

        let savedImageData = null;

        function startDrawing(e) {
            if (!currentShape) return;
            
            isDrawing = true;
            const rect = patternCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            // 현재 캔버스 상태 저장 (도형 미리보기용)
            savedImageData = patternCtx.getImageData(0, 0, patternCanvas.width, patternCanvas.height);
            
            // 자유 그리기는 시작점 설정
            if (currentShape === 'free') {
                patternCtx.beginPath();
                patternCtx.moveTo(startX, startY);
            }
        }

        function draw(e) {
            if (!isDrawing || !currentShape) return;
            
            const rect = patternCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            if (currentShape === 'free') {
                // 자유 그리기: 실시간으로 선 그리기
                patternCtx.lineWidth = 3;
                patternCtx.lineCap = 'round';
                patternCtx.strokeStyle = document.getElementById('pattern-color')?.value || '#3B82F6';
                patternCtx.lineTo(currentX, currentY);
                patternCtx.stroke();
                patternCtx.beginPath();
                patternCtx.moveTo(currentX, currentY);
            } else {
                // 도형 그리기: 미리보기 (반투명)
                patternCtx.putImageData(savedImageData, 0, 0);
                
                patternCtx.fillStyle = document.getElementById('pattern-color')?.value || '#3B82F6';
                patternCtx.strokeStyle = document.getElementById('pattern-color')?.value || '#3B82F6';
                patternCtx.lineWidth = 2;
                patternCtx.globalAlpha = 0.5;
                
                if (currentShape === 'circle') {
                    const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                    patternCtx.beginPath();
                    patternCtx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    patternCtx.fill();
                    patternCtx.stroke();
                } else if (currentShape === 'rect') {
                    patternCtx.fillRect(startX, startY, currentX - startX, currentY - startY);
                    patternCtx.strokeRect(startX, startY, currentX - startX, currentY - startY);
                } else if (currentShape === 'triangle') {
                    patternCtx.beginPath();
                    patternCtx.moveTo(startX, startY);
                    patternCtx.lineTo(currentX, currentY);
                    patternCtx.lineTo(startX * 2 - currentX, currentY);
                    patternCtx.closePath();
                    patternCtx.fill();
                    patternCtx.stroke();
                }
                
                patternCtx.globalAlpha = 1.0;
            }
        }

        function stopDrawing(e) {
            if (!isDrawing || !currentShape) {
                isDrawing = false;
                return;
            }
            
            const rect = patternCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            
            // 자유 그리기는 이미 그려졌으므로 여기서는 도형만 처리
            if (currentShape !== 'free') {
                // 저장된 이미지 복원 후 최종 도형 그리기
                patternCtx.putImageData(savedImageData, 0, 0);
                
                patternCtx.fillStyle = document.getElementById('pattern-color')?.value || '#3B82F6';
                patternCtx.strokeStyle = document.getElementById('pattern-color')?.value || '#3B82F6';
                patternCtx.lineWidth = 2;
                patternCtx.globalAlpha = 1.0;
                
                if (currentShape === 'circle') {
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    patternCtx.beginPath();
                    patternCtx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    patternCtx.fill();
                    patternCtx.stroke();
                } else if (currentShape === 'rect') {
                    patternCtx.fillRect(startX, startY, endX - startX, endY - startY);
                    patternCtx.strokeRect(startX, startY, endX - startX, endY - startY);
                } else if (currentShape === 'triangle') {
                    patternCtx.beginPath();
                    patternCtx.moveTo(startX, startY);
                    patternCtx.lineTo(endX, endY);
                    patternCtx.lineTo(startX * 2 - endX, endY);
                    patternCtx.closePath();
                    patternCtx.fill();
                    patternCtx.stroke();
                }
            }
            
            savedImageData = null;
            isDrawing = false;
        }

        function drawShape(shape) {
            currentShape = shape;
            isDrawing = false;
        }

        function setDrawingMode(mode) {
            currentShape = mode;
            isDrawing = false;
        }

        function clearPatternCanvas() {
            if (patternCtx) {
                patternCtx.clearRect(0, 0, patternCanvas.width, patternCanvas.height);
            }
        }

        function savePatternDrawing() {
            if (!patternCanvas) return;
            const imageData = patternCanvas.toDataURL('image/png');
            state.appData.senseExpressionPattern = imageData;
            render();
        }

        function clearPatternDrawing() {
            state.appData.senseExpressionPattern = null;
            patternCanvas = null;
            patternCtx = null;
            currentShape = null;
            isDrawing = false;
            render();
        }

        // =========================
        // User ID 생성
        // =========================
        function generateUserId() {
            // 간단한 고유 ID 생성 (타임스탬프 + 랜덤)
            return 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
        }

        // =========================
        // App Initialization
        // =========================
        window.addEventListener('DOMContentLoaded', () => {
            // 로컬 스토리지에서 사용자 ID 불러오기 또는 생성
            const storedUserId = localStorage.getItem('melodymind_userId');
            if (storedUserId) {
                state.userId = storedUserId;
            } else {
                state.userId = generateUserId();
                localStorage.setItem('melodymind_userId', state.userId);
            }
            
            console.log(`🎵 사용자 ID: ${state.userId}`);
            render();
        });
    </script>
</body>
</html>
